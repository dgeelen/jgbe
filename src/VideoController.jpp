#ifndef USE_JAVA_MOBILE
#include "Global.inc"
#include "SaveLoad.inc"

import java.io.*;
#ifdef USE_JAVA_MOBILE
import javax.microedition.lcdui.*;
import javax.microedition.lcdui.game.GameCanvas;
#else
import javax.swing.*;
import java.awt.*;
import java.awt.image.*;
#endif

public final class VideoController {
	private static final int MIN_WIDTH  = 160;
	private static final int MIN_HEIGHT = 144;

#ifdef USE_JAVA_MOBILE
	private static Graphics listener = null;
#else
	private static IVideoListener listener = null;
	private static Image drawImg[] = new Image[2];
	private static int drawData[];
#endif
	private static int curDrawImg = 0;

	private static int CurrentVRAMBank=0;
	protected static int VRAM[]=new int[0x4000]; //8k per bank, 2 banks, flattened;
	protected static int OAM[] =new int[0xa0];   //Sprite Attribute Table;

	protected static boolean isCGB;

	//Note: all these variables are actually initialised in reset()
	protected static int LY=0;
	protected static int LYC=0;
	protected static int SCX=0;
	protected static int SCY=0;
	protected static int WX=0;
	protected static int WY=0;
	protected static int LCDC=0;
	protected static int STAT=0;
	protected static int ISTAT=0;      // Internal copy of STAT (bits 6-3 only). See gmb-spec.txt for details
	protected static int ISTAT_mask; // Used to mask out certain bits of ISTAT upon interrupt execution
	private static int LCDCcntdwn=0;

	public static boolean useSubscanlineRendering = true;

	protected static int curBGY;
	protected static int curWNDY;

	protected static int[][][] Scalerx4 = new int[0x100][4][4];

	// Looks a lot like Origional Gameboy
	private static final int GRAYSHADES[][] = { {0xa0, 0xe0, 0x20},   // WHITE
	                                            {0x70, 0xb0, 0x40},   // LIGHTGRAY
	                                            {0x40, 0x70, 0x32},   // DARKGRAY
	                                            {0x10, 0x50, 0x26} }; // BLACK

	private static int GrayColors[][][] = { GRAYSHADES, GRAYSHADES, GRAYSHADES };

	protected static int BGPI=0;              //BCPS/BGPI - CGB Mode Only - Background Palette Index
	private static int BGPD[]=new int[8*4*2]; //BCPD/BGPD - CGB Mode Only - Background Palette Data

	protected static int OBPI=0;              //OCPS/OBPI - CGB Mode Only - Sprite Palette Index
	private static int OBPD[]=new int[8*4*2]; //OCPD/OBPD - CGB Mode Only - Sprite Palette Data

	/* caching vars */
#ifdef USE_JAVA_MOBILE
	#define BLITPIXTYPE int[]
	private static int blitImg[][][] = new static int[144][160][3]; // [y][x]
	private static int palColors[][] = new static int[8*4*2][3];
#else
	#define BLITPIXTYPE int
	private static BLITPIXTYPE blitImg[][]      = new BLITPIXTYPE[144][160]; // [y][x]
	private static BLITPIXTYPE blitImg_prev[][] = new BLITPIXTYPE[144][160]; // [y][x]
	private static BLITPIXTYPE palColors[]      = new BLITPIXTYPE[8*4*2];
#endif
	private static int patpix[][][] = new int[4096][][];   // see updatepatpix()
	private static boolean patdirty[] = new boolean[1024]; // see updatepatpix()
	private static boolean anydirty = true;                // see updatepatpix()
// 	private boolean alldirty = true;                // see updatepatpix()

	private static long pfreq;
	private static long ptick;
	private static long ftick;

	private static int scale = 3;
	public static int nscale = 3;
	private static int cfskip = 0;
	public static int fskip = 1; // 1 is off
	public static boolean MixFrames; // Mix together last N frames
	public static boolean allow_writes_in_mode_2_3=true;

	public static void setGrayShade(int i, int j, Color c) {
		GrayColors[i][j][0] = c.getRed();
		GrayColors[i][j][1] = c.getGreen();
		GrayColors[i][j][2] = c.getBlue();
		updateMonoColData(0); //???
		updateMonoColData(1);
		updateMonoColData(2);
	}

	/* NOTE: Do not use 'clone', for it creates a 'shallow' copy when used
	 *       with 2d arrays, meaning that sub-arrays are still shared.
	 * TODO: Make this a proper function
	 */
	#define unshallowCloneInto(x, y) { \
		y = new int[4][3]; \
		for(int abc=0; abc<4; ++abc) \
			for(int bca=0; bca<3; ++bca) \
				y[abc][bca]=x[abc][bca]; \
	}

	public static void setGrayShades(int[][][] g) {
		//NOTE: Somehow this function can not use unshallowCloneInto and updateMonoColData
		setGrayShades(g[0], g[1], g[2]);
	}

	public static void setGrayShades(int[][] g) {
		unshallowCloneInto(g, GrayColors[0]);
		unshallowCloneInto(g, GrayColors[1]);
		unshallowCloneInto(g, GrayColors[2]);
		updateMonoColData(0); //??? <-- What do these question marks here?
		updateMonoColData(1);
		updateMonoColData(2);
	}

	public static void setGrayShades(int[][] g1, int[][] g2, int[][] g3) {
		unshallowCloneInto(g1, GrayColors[0]);
		unshallowCloneInto(g2, GrayColors[1]);
		unshallowCloneInto(g3, GrayColors[2]);
		updateMonoColData(0); //??? <-- And here?
		updateMonoColData(1);
		updateMonoColData(2);
	}

	public static int[][] getGrayShade(int i) {
		return GrayColors[i];
	}

	public static int[][][] getGrayShades() {
		return GrayColors;
	}


	public static void restart() { // LCD off -> on
		LY=0;
		STAT=STAT&0xFC;//*KIGB=0x85(?)*/0x85 /*used to be: 0x04*/; // FF41 - STAT - LCDC Status (R/W) // LY==LYC bit set
		ISTAT=STAT;
		ISTAT_mask=0xff;
		STAT_statemachine_state=0;
		LCDCcntdwn=80;
	}

	public static void reset() {
		CurrentVRAMBank=0;
		LY=0;
		LYC=0;
		SCX=0;
		SCY=0;
		WX=0;
		WY=0;
		LCDC=CPU.BIOS_enabled?0x00:0x91; // init with screen on, tile data from 8000-8FFF, bg active
		STAT=/*KIGB=0x85(?)*/0x85 /*used to be: 0x04*/; // FF41 - STAT - LCDC Status (R/W) // LY==LYC bit set
		ISTAT=STAT;
		ISTAT_mask=0xff;
		STAT_statemachine_state=0;
		LCDCcntdwn=80;

		BGPI=0;              //BCPS/BGPI - CGB Mode Only - Background Palette Index
		OBPI=0;              //OCPS/OBPI - CGB Mode Only - Sprite Palette Index
		anydirty = true;                // see updatepatpix()
		for(int i=0; i<1024; ++i) {
			patdirty[i]=true;
		}
		updatepatpix();

		for (int i = 0; i < 0x20; ++i) {
			OBPD[i*2] = OBPD[i*2+1] = 0;
			BGPD[i*2] = BGPD[i*2+1] = 0;
			updateBGColData(i);
			updateOBColData(i);
		};
		updateMonoColData(0);
		updateMonoColData(1);
		updateMonoColData(2);

		for (int i = 0; i < 0xa0; ++i)
			OAM[i] = 0;
		for (int i = 0; i < 0x4000; ++i)
			VRAM[i] = 0;
	}

	public static void initialise() {
#ifndef USE_JAVA_MOBILE
		drawImg=new Image[2];
#endif
		scale();
		reset(); // Initialise all variables
	}


	static SAVELOAD_FUNCTION {
		SL_INT(CurrentVRAMBank);
		SL_ARR(UINT8, VRAM, 0x4000);
		SL_ARR(UINT8, OAM, 0xa0);

		SL_UINT8(LY);
		SL_UINT8(LYC);
		SL_UINT8(SCX);
		SL_UINT8(SCY);
		SL_UINT8(WX);
		SL_UINT8(WY);
		SL_UINT8(LCDC);
		SL_IF_VERSION(15, -1) {
			SL_INT(LCDCcntdwn);
			SL_INT(mode3duration);
		}
		SL_IF_VERSION(18, -1) {
			SL_INT(STAT_statemachine_state);
		}
		SL_UINT8(STAT);
		SL_IF_VERSION(24,-1) {
			SL_UINT8(ISTAT);
			SL_UINT8(ISTAT_mask);
		} else {
			ISTAT = STAT;
			ISTAT_mask = 0xff;
		}
		SL_IF_VERSION(-1, 17) {
			// OLD savestates may crash JGBE (currently, savestate version 18),
			// this probably fuxx0rs timing, but should prevent crashes
			switch(STAT&3) {
				case 0:
					LCDCcntdwn=204;
					STAT_statemachine_state=2;
					break;
				case 1:
					LCDCcntdwn=0;
					STAT_statemachine_state=3;
					break;
				case 2:
					LCDCcntdwn=80;
					STAT_statemachine_state=0;
					break;
				case 3:
					LCDCcntdwn=172;
					STAT_statemachine_state=1;
					break;
			}
		}

		SL_UINT8(BGPI);
		SL_ARR(UINT8, BGPD, 8*4*2);

		SL_UINT8(OBPI);
		SL_ARR(UINT8, OBPD, 8*4*2);

		SL_IF_VERSION(8, -1) SL_UINT8(curWNDY);

		if (SL_LOAD) {
			for(int i=0; i<1024; ++i) {
				patdirty[i]=true;
			}
			anydirty = true;
			for (int i = 0; i < 0x20; ++i) {
				updateBGColData(i);
				updateOBColData(i);
			};
			updateMonoColData(0);
			updateMonoColData(1);
			updateMonoColData(2);
			setSpritesOnScanline();
		}
	}

#ifndef USE_JAVA_MOBILE
	public static void addListener(IVideoListener vl) {

		listener = vl; // only 1 listener at a time currently :-p
		scale();
	}
#else
	public static void addListener(Graphics grfx) {
		listener = grfx;
		//scale(drawImg[0].getWidth(null), drawImg[0].getHeight(null));
	}
#endif

	private static void scale() {
		scale = nscale;
		int width = scale*MIN_WIDTH;
		int height = scale*MIN_HEIGHT;
#ifndef USE_JAVA_MOBILE
		drawImg[0]=new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		drawImg[1]=new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
#endif
	}

#ifndef USE_JAVA_MOBILE
	public static Image getImage() {
		return drawImg[curDrawImg]; // display image not being drawn to
	}
#endif

	private static void palChange(int palcol, int r, int g, int b) {
#ifdef USE_JAVA_MOBILE
		palColors[palcol][0] = r;
		palColors[palcol][1] = g;
		palColors[palcol][2] = b;
#else
		palColors[palcol] = ((r<<16)|(g<<8)|(b<<0));
#endif
	}

// put pixel into the blit buffer using specified color and palet
#define DRAWPIX(x, pal, col) { \
		blitLine[x] = palColors[pal | col]; \
} \

// draw pixel using a moving index into a flat array
#define BLIT_PIX_WI(i, col) \
	drawData[++i] = col

// draw set of pixels into a flat array
#define BLIT_PIX_WA(src, srcoff, len, ind) \
	System.arraycopy(src, srcoff, drawData, ind, len)

#define BLIT_PIX_USE_JAVA_MOBILE(x,y, col) { \
	int[] tcol = col; \
	listener.setColor(tcol[0], tcol[1], tcol[2]); \
	listener.drawRect(x,y, 0, 0); \
}

#define EQ(a,b) ((a) == (b))
//#define EQ(a,b) ((a).equals(b))

#ifdef USE_JAVA_MOBILE
// UNTESTED! dont know if it even compiles...
#undef BLIT_PIX_WI
#define BLIT_PIX_WI(i, col) { \
	BLIT_PIX_USE_JAVA_MOBILE( i % (scale * 160), i / (scale * 160), col); \
	++i; \
}
#undef BLIT_PIX_WA(src, srcoff, len, ind) { \
	for (int blit_i = 0, int blit_ind = ind; blit_i < len; ++i)\
		BLIT_PIX_WI(ind, src[srcoff+blit_i]); \
}
#endif

/* Note: see http://www.compuphase.com/graphic/scale3.htm */
#define AVERAGE(a, b)   ( ((((a) ^ (b)) & 0xfffefefe) >> 1) + ((a) & (b)) )


	static long lastms;
	private static void blitImage() {
		cfskip--;
		if (cfskip < 0) {
			cfskip += fskip;
			if (scale != nscale) scale();
	#ifndef USE_JAVA_MOBILE
			WritableRaster wr = ((BufferedImage)drawImg[curDrawImg^1]).getRaster();
			drawData = ((DataBufferInt)wr.getDataBuffer()).getData();
	#endif

			/* Mix-Frame mode */
			if(MixFrames)
				for(int y=0; y<144; ++y) {
					for(int x=0; x<160; ++x) {
						blitImg[y][x] = AVERAGE(blitImg[y][x], blitImg_prev[y][x]);
						blitImg_prev[y][x] = blitImg[y][x];
					}
				}

			if (scale == 1) {
				for (int y = 0; y < 144; ++y) {
					BLITPIXTYPE[] blitLine = blitImg[y];
					BLIT_PIX_WA(blitLine, 0, 160, y*160);
				}
			}
			else if (scale == 2) {
				// 'scale2x' algo // http://scale2x.sourceforge.net/algorithm.html
				#define A blitLine1[xn]
				#define B blitLine1[x]
				#define C blitLine1[xp]
				#define D blitLine2[xn]
				#define E blitLine2[x]
				#define F blitLine2[xp]
				#define G blitLine3[xn]
				#define H blitLine3[x]
				#define I blitLine3[xp]
				int ti1 = -1, ti2 = -1;
				ti2 += 160*2;
				for (int y = 0; y < 144; ++y) {
					int yn = (y==0  )?0  :y-1;
					int yp = (y==143)?143:y+1;
					BLITPIXTYPE[] blitLine2 = blitImg[y];
					BLITPIXTYPE[] blitLine1 = blitImg[yn];
					BLITPIXTYPE[] blitLine3 = blitImg[yp];
					for (int x = 0; x < 160; ++x) {
						int xn = (x==0  )?0  :x-1;
						int xp = (x==159)?159:x+1;
						if (!EQ(blitLine2[xn], blitLine2[xp])
						&&  !EQ(blitLine1[x] , blitLine3[x])) {
							BLIT_PIX_WI(ti1, EQ(B, D) ? D : E);
							BLIT_PIX_WI(ti1, EQ(B, F) ? F : E);
							BLIT_PIX_WI(ti2, EQ(H, D) ? D : E);
							BLIT_PIX_WI(ti2, EQ(H, F) ? F : E);
						}
						else {
							BLITPIXTYPE col = E;
							BLIT_PIX_WI(ti1, col);
							BLIT_PIX_WI(ti1, col);
							BLIT_PIX_WI(ti2, col);
							BLIT_PIX_WI(ti2, col);
						}
					}
					ti1 += 160*2;
					ti2 += 160*2;
				}
			} else if (scale == 3) {
				// 'scale3x' algo // http://scale2x.sourceforge.net/algorithm.html
				int ti1 = -1, ti2 = -1, ti3 = -1;
				ti2 += 160*3;
				ti3 += 160*3*2;
				for (int y = 0; y < 144; ++y) {
					int yn = (y==0  )?0  :y-1;
					int yp = (y==143)?143:y+1;
					BLITPIXTYPE[] blitLine2 = blitImg[y];
					BLITPIXTYPE[] blitLine1 = blitImg[yn];
					BLITPIXTYPE[] blitLine3 = blitImg[yp];
					for (int x = 0; x < 160; ++x) {
						int xn = (x==0  )?0  :x-1;
						int xp = (x==159)?159:x+1;
						if (!EQ(B, H) && !EQ(D, F)) {
							BLIT_PIX_WI(ti1 , EQ(D, B) ? D : E);
							BLIT_PIX_WI(ti1 , (EQ(D, B) && !EQ(E, C)) || (EQ(B, F) && !EQ(E, A))? B : E);
							BLIT_PIX_WI(ti1 , EQ(B, F) ? F : E);
							BLIT_PIX_WI(ti2 , (EQ(D, B) && !EQ(E, G)) || (EQ(D, H) && !EQ(E, A))? D : E);
							BLIT_PIX_WI(ti2 , E);
							BLIT_PIX_WI(ti2 , (EQ(B, F) && !EQ(E, I)) || (EQ(H, F) && !EQ(E, C))? F : E);
							BLIT_PIX_WI(ti3 , EQ(D, H) ? D : E);
							BLIT_PIX_WI(ti3 , (EQ(D, H) && !EQ(E, I)) || (EQ(H, F) && !EQ(E, G))? H : E);
							BLIT_PIX_WI(ti3 , EQ(H, F) ? F : E);
						} else {
							BLITPIXTYPE col = E;
							BLIT_PIX_WI(ti1 , col);
							BLIT_PIX_WI(ti1 , col);
							BLIT_PIX_WI(ti1 , col);
							BLIT_PIX_WI(ti2 , col);
							BLIT_PIX_WI(ti2 , col);
							BLIT_PIX_WI(ti2 , col);
							BLIT_PIX_WI(ti3 , col);
							BLIT_PIX_WI(ti3 , col);
							BLIT_PIX_WI(ti3 , col);
						}
					}
					ti1 += 160*3*2;
					ti2 += 160*3*2;
					ti3 += 160*3*2;
				}
			}
			else if (scale == 4) {
				// 'scalex4' algo // invented by Simon Sasburg
				int ti1 = -1, ti2 = -1, ti3 = -1, ti4 = -1;
				ti2 += 160*4;
				ti3 += 160*4*2;
				ti4 += 160*4*3;
				for (int y = 0; y < 144; ++y) {
					int yn = (y==0  )?0  :y-1;
					int yp = (y==143)?143:y+1;
					BLITPIXTYPE[] blitLine2 = blitImg[y];
					BLITPIXTYPE[] blitLine1 = blitImg[yn];
					BLITPIXTYPE[] blitLine3 = blitImg[yp];
					for (int x = 0; x < 160; ++x) {
						int xn = (x==0  )?0  :x-1;
						int xp = (x==159)?159:x+1;
	/*	Reference, this one works * /
							BLIT_PIX_WI(ti1, EQ(B, D) ? B : E);
							BLIT_PIX_WI(ti1, EQ(B, D) ? B : E);
							BLIT_PIX_WI(ti1, EQ(B, F) ? B : E);
							BLIT_PIX_WI(ti1, EQ(B, F) ? B : E);
							BLIT_PIX_WI(ti2, EQ(B, D) ? B : E);
							BLIT_PIX_WI(ti2, E);
							BLIT_PIX_WI(ti2, E);
							BLIT_PIX_WI(ti2, EQ(B, F) ? B : E);
							BLIT_PIX_WI(ti3, EQ(H, D) ? H : E);
							BLIT_PIX_WI(ti3, E);
							BLIT_PIX_WI(ti3, E);
							BLIT_PIX_WI(ti3, EQ(H, F) ? H : E);
							BLIT_PIX_WI(ti4, EQ(H, D) ? H : E);
							BLIT_PIX_WI(ti4, EQ(H, D) ? H : E);
							BLIT_PIX_WI(ti4, EQ(H, F) ? H : E);
							BLIT_PIX_WI(ti4, EQ(H, F) ? H : E);

	/*/// However, this one should be a bit faster (However, my short test only gives a small increase of ~3fps)
						if (EQ(B, D)) {
								BLIT_PIX_WI(ti1, B);
								BLIT_PIX_WI(ti1, B);
								BLIT_PIX_WI(ti2, B);
						} else {
								BLIT_PIX_WI(ti1, E);
								BLIT_PIX_WI(ti1, E);
								BLIT_PIX_WI(ti2, E);
						}
						BLIT_PIX_WI(ti2, E);
						BLIT_PIX_WI(ti2, E);
						if (EQ(B, F)) {
							BLIT_PIX_WI(ti1, B);
							BLIT_PIX_WI(ti1, B);
							BLIT_PIX_WI(ti2, B);
						} else {
							BLIT_PIX_WI(ti1, E);
							BLIT_PIX_WI(ti1, E);
							BLIT_PIX_WI(ti2, E);
						}
						if (EQ(H, D)) {
								BLIT_PIX_WI(ti3, H);
								BLIT_PIX_WI(ti4, H);
								BLIT_PIX_WI(ti4, H);
						} else {
								BLIT_PIX_WI(ti3, E);
								BLIT_PIX_WI(ti4, E);
								BLIT_PIX_WI(ti4, E);
						}
						BLIT_PIX_WI(ti3, E);
						BLIT_PIX_WI(ti3, E);
						if (EQ(H, F)) {
							BLIT_PIX_WI(ti3, H);
							BLIT_PIX_WI(ti4, H);
							BLIT_PIX_WI(ti4, H);
						} else {
							BLIT_PIX_WI(ti3, E);
							BLIT_PIX_WI(ti4, E);
							BLIT_PIX_WI(ti4, E);
						} /* */
					}
					ti1 += 160*4*3;
					ti2 += 160*4*3;
					ti3 += 160*4*3;
					ti4 += 160*4*3;
				}
			}
			curDrawImg ^= 1;
			if (listener != null) listener.newVideoImage();
	}
		curBGY = 0;
		curWNDY = 0;

#undef A
#undef B
#undef C
#undef D
#undef E
#undef F
#undef G
#undef H
#undef I
	}

	public static void updateMonoColData(int index) {
		// index = 0 -> FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only
		// index = 1 -> FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only
		// index = 2 -> FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only


		if (isCGB) return;

		int [][] curColors = GrayColors[index];

		int value = CPU.IOP[index+0x47];//FIXME:do not use, this is called from constructor! CPU.read(index + 0xff47); // could fix this to hold those values ourselves..

		/* here we juggle the pallete numbers a bit
		 * background palletes have bit 4 (0x08) set
		 */
		if (index==0) index= (0x20>>2);
		else --index;

		/* Here we set the colors in this pallete to the correct rgb values
		 * Color indexes consist of 2 color bits and 4 pallete bits (ppppcc)
		 */
		int temp[] = null;
		temp = curColors[(value>>0)&3]; palChange((index<<2) | 0, temp[0], temp[1], temp[2]);
		temp = curColors[(value>>2)&3]; palChange((index<<2) | 1, temp[0], temp[1], temp[2]);
		temp = curColors[(value>>4)&3]; palChange((index<<2) | 2, temp[0], temp[1], temp[2]);
		temp = curColors[(value>>6)&3]; palChange((index<<2) | 3, temp[0], temp[1], temp[2]);
	}

	public static void setBGColData(int value) {
		BGPD[BGPI&0x3f] = value;
		int bnum = (BGPI & 0x3e) >> 1;
		updateBGColData(bnum);
		if ((BGPI&(1<<7))!=0)
			++BGPI;
	}

	public static void updateBGColData(int bnum) {
		int base = bnum << 1;

		// calculate color now
		int data = BGPD[base] | (BGPD[base+1]<<8);
		int palnum = base >> 3;
		int colnum = (base >> 1) & 3;
		int r = (data >>  0) & 0x1F;
		int g = (data >>  5) & 0x1F;
		int b = (data >> 10) & 0x1F;

		r <<= 3; r |= (r >> 5);
		g <<= 3; g |= (g >> 5);
		b <<= 3; b |= (b >> 5);
		// TODO gb->vga rgb conv
		// i think that was it... gnuboy doesnt seem
		// to do anything more and there it works
		// fading issue is somethere else, maybe int timing issue?

		palChange((palnum << 2) | colnum | 0x20, r, g, b);
	}

	public static int getBGColData() {
		return BGPD[BGPI&0x3f];
	}

	public static void setOBColData(int value) {
		OBPD[OBPI&0x3f] = value;
		int bnum = (OBPI & 0x3e) >> 1;
		updateOBColData(bnum);
		if ((OBPI&(1<<7))!=0)
			++OBPI;
	}

	public static void updateOBColData(int bnum) {
		int base = bnum << 1;

		// calculate color now
		int data = OBPD[base] | (OBPD[base+1]<<8);
		int palnum = base >> 3;
		int colnum = (base >> 1) & 3;
		int r = (data >>  0) & 0x1F;
		int g = (data >>  5) & 0x1F;
		int b = (data >> 10) & 0x1F;

		r <<= 3; r |= (r >> 5);
		g <<= 3; g |= (g >> 5);
		b <<= 3; b |= (b >> 5);

		palChange((palnum << 2) | colnum, r, g, b);
	}

	public static int getOBColData() {
		return OBPD[OBPI&0x3f];
	}

	/** updates contents of patpix[][][] when it is outdated
	 *
	 *  when anydirty is false nothing will be done
	 *  when alldirty is true all patterns will be updated
	 *  when patdirty[i] is true pattern i will be updated
	 *
	 *  patpix[i] is an 8x8 (y,x) matrix with colors of the tile
	 *  i needs to 0..384-1 or 512..896
	 *
	 *  patpix[   0..1024-1] hold normal patterns
	 *  patpix[1024..2048-1] hold patterns flipped x-wise
	 *  patpix[2048..3072-1] hold patterns flipped y-wise
	 *  patpix[3072..3072-1] hold patterns flipped x-wise and y-wise
	 */
	private static void updatepatpix() {
		if (!anydirty/* && !alldirty*/)
			return;

		for (int i = 0; i < 1024; ++i)
		{
			if (i == 384) i = 512;
			if (i == 896) break;
			if (!patdirty[i]/* && !alldirty*/) continue;
			if (patpix[i]==null) {
				patpix[i]      = new int[8][8];
				patpix[i+1024] = new int[8][8];
				patpix[i+2048] = new int[8][8];
				patpix[i+3072] = new int[8][8];
			}
			patdirty[i] = false;

			for (int y = 0; y < 8; ++y) {
				int lineofs = (i*16) + (y*2);
				for (int x = 0; x < 8; ++x) { // not really x, but 7-x
					// this info is always in bank 0, so read directly from VRAM[0]
					int col = (VRAM[lineofs]>>x)&1;
					col |= ((VRAM[lineofs+1]>>x)&1)<<1;
					patpix[i]     [y]  [7-x] = col;
					patpix[i+1024][y]  [x]   = col;
					patpix[i+2048][7-y][7-x] = col;
					patpix[i+3072][7-y][x]   = col;
				}
			}
		}
		anydirty = false;
		//alldirty = false;
	}


	/*****
	 * Note: Please refer to (and update) docs/notes_on_video_timing.txt when
	 * making changes to render()
	 *
	 * ps: Still not sure about what mode(s) to be in when LCD is off,
	 *     and neither do I know if we should generate any interrupts when
	 *     the LCD is off (if at all)
	 *
	 *     From gmb-spec:
	 *        As long as the display is disabled LY will
	 *        read 0, no INT 40 or INT 48 are generated,
	 *        when the display is re-enabled, it will start
	 *        at LY=0.
	 *
	 * ps:   Prehistorik Man does some funky shit at d600 (sub scanline render?).
	 ****/
	static int STAT_statemachine_state = 0;
	static int mode3duration = 0;
	static int scanlinepos = 0;
	public static int render(int cycles) { // Renders in real clock cycles
		LCDCcntdwn -= cycles;
		while (LCDCcntdwn <= 0) {
			switch (STAT_statemachine_state) {
				case 0: // currently in mode 2, switch to mode 3
					//Note: check if this can change before mode 3 (I think not -> Video memory should be locked)
					mode3duration = 172 + 10*setSpritesOnScanline();//getSpriteCountOnScanline(LY);
					LCDCcntdwn += mode3duration; // Mode 3 lasts longer depending on the nr of sprites on the scanline
					STAT = (STAT & 0xFC) | 3;
					++STAT_statemachine_state;
 					if (!useSubscanlineRendering) {
						// Test: What if the VC renders the BG internally in mode 2?
						// Result: (Currently?) works better for some games (e.g.
						//          top line in Castellian doesn't blink)
						renderScanline();
					} else {
						// Reset scanline rendering state, everything is rendered in mode 3
						// FIXME/NOTE: The beginning of the scanline might already have to have been drawn here, since LCDCcntdwn<=0
						pixpos = -(SCX&7); // First tile may be drawn partly off screen
						cyclepos = 0;
						curSprite = 0;
						updatepatpix();
					}
					break;
				case 1: // currently in mode 3, switch to mode 0
					if(useSubscanlineRendering)
						renderScanlinePart(); // Render (remainder of) background and sprites
					//else // rendering in mode2 is better
						//renderScanline();

					LCDCcntdwn += (isCGB ? 376 : 372) - mode3duration; //mode 0 duration - mode 3 duration - hblank_dma
					STAT &= 0xFC; //switch to mode 0: STAT = (STAT & 0x7C) | 0;
					if ((ISTAT&(1<<3))!=0) {
						CPU.triggerInterrupt(1); // mode 0 HBlank interrupt
						ISTAT_mask &= 0x0f; // Clear all bits above bit 3
					}
					if (LY<144) CPU.elapseTime(CPU.hblank_dma());
					++STAT_statemachine_state;
					break;
				case 2: // currently in mode 0, nearing the end, time to increase LY
					LY++;
					STAT = (STAT & (~(1 << 2))); // Unset LY==LYC
					LCDCcntdwn += (isCGB ? 0 : 4); // only 4 more cycles of mode 0 remain at this point
					++STAT_statemachine_state;
					break;
				case 3: // currently in mode 0, switch to mode [2 or 1]
					if (LY<144) { // switch to mode 2
						LCDCcntdwn += 80;
						STAT = (STAT & 0xFC) | 2;
						if (LY == LYC) {         // This is checked while changing to the new scanline
							STAT = STAT | (1 << 2);    // Set LY=LYC
							if ((ISTAT&(1<<6))!=0) {
								CPU.triggerInterrupt(1); // LYC Coincidence interrupt
								ISTAT_mask &= 0x7f; // Clear all bits above bit 6
							}
						}
						if ((ISTAT&(1<<5))!=0) {
							CPU.triggerInterrupt(1); // Mode2 OAM interrupt
							ISTAT_mask &= 0x3f; // Clear all bits above bit 5
						}
						STAT_statemachine_state=0;
					}
					else { // switch to mode 1
						STAT = (STAT & 0xFC) | 1;
						++STAT_statemachine_state;
						if((LCDC&0x80)!=0) CPU.triggerInterrupt(0);    // VBlank interrupt (0x40 / VBLANK)
						if ((ISTAT&(1<<4))!=0) {
							CPU.triggerInterrupt(1); // Mode 1 VBlank interrupt (0x48 / LCDC STAT)
							ISTAT_mask &= 0x1f; // Clear all bits above bit 4
						}
						blitImage();
					}
					break;
				case 4: // currently in mode 1(VBlank), beginning of the scanline
					if (LY==LYC) {
						STAT = STAT | 4;       // Set LY=LYC (even for LY==153)
						if((ISTAT&(1<<6))!=0) {
							CPU.triggerInterrupt(1);
							ISTAT_mask &= 0x7f; // Clear all bits above bit 6
						}
					}
					if (LY==153) LY=0;
					LCDCcntdwn += (isCGB ? 456 : 452);       // end 4 cycles before the end so we can increase LY just before the next scanline
					++STAT_statemachine_state;
					break;
				case 5: // currently in mode 1(VBlank), nearing 'scanline' end
					LCDCcntdwn += (isCGB ? 0 : 4); // only 4 more cycles of this scanline remain at this point
					if (LY==0) { // We're on scanline 153, time for mode 2
						++STAT_statemachine_state;
					}
					else {       // Stay in VBlank
						++LY;
						STAT = (STAT & (~4)); // Unset LY==LYC
						--STAT_statemachine_state;
					}
					break;
				case 6: // Time to go to back to mode 2
					STAT = (STAT&0xfc) | 2;
					if ((LY==LYC)&&(ISTAT&(1<<6))!=0) {
						CPU.triggerInterrupt(1); // LYC Coincidence interrupt
						ISTAT_mask &= 0x7f; // Clear all bits above bit 6
					}
					if ((ISTAT&(1<<5))!=0) {
						CPU.triggerInterrupt(1); // Mode2 OAM interrupt
						ISTAT_mask &= 0x3f; // Clear all bits above bit 5
					}
					LCDCcntdwn += 80;
					STAT_statemachine_state = 0;
					break;
				default:
					ASSERT(false); //We should never get here!
					break;
			}
		}
		ASSERT(LCDCcntdwn > 0);
		return LCDCcntdwn;
	}

	// Render enough pixels for the ammount of time that has passed (from LCDCcntdwn to LCDCcntdwn + cycles).
	static int   pixpos     = 0;
	static int   cyclepos   = 0;
	static int[] zbuffer    = new int[160]; // see renderScanlineSprites
	static int   curSprite  = 0;
	private static void renderScanlinePart() {
		if((STAT_statemachine_state != 1)) return;
		blitLine = blitImg[LY];
		if((LCDC&0x80)==0) { // Draw empty scanline if LCD is disabled
			for(int i=pixpos; i<160; ++i) {
				int x = pixpos+i;
				if((x>=0)&&(x<160))
					DRAWPIX(x, 32, 0); //FIXME: Wrong color!
			}
			pixpos=160;
			return;
		}

		/* rendering takes between 172 and 272 cycles, depending on #sprites.
		 * Looking at the source for VBA-M (the goggles, they do nothing!), sprites are rendered
		 * 'inplace', while rendering the background. Thus in their emu changes in SCX,SCY and
		 * pallettes are not reflected until a sprite finishes rendering.
		 * Or rather: 8 pixels (they render 8 pixels at a time)
		 *
		 * Priorities are as follows:
		 *
		 */

		// Render one bg tile = 8px = 8 cycles -> leaves 4 cycles slack?
		// (172-21*8)=4, because we need to render 21 tiles

		int newLCDCcntdwn = LCDCcntdwn - (int)(CPU.TotalCycleCount - CPU.lastVCRenderCycleCount); // NR of cycles left till end of scanline
		int cyclesToRender = (mode3duration - newLCDCcntdwn - cyclepos - 4);
		cyclepos += cyclesToRender;

		while(cyclesToRender>0) { // we render 8px at a time
			int sprXPos = OAM[spritesOnScanline[curSprite]|1]-8-pixpos;
			if((sprXPos>=0) && (sprXPos<8) && (curSprite<spriteCountOnScanline-1)) { // Sprite starts within next 8 px
				cyclesToRender-=2; // rendering a sprite takes 10 cycles (2+8), no bg tile is rendered
				++curSprite; // Select next sprite
				pixpos-=8;
			} else
			if((!isCGB) && ((LCDC&(1<<0))==0)) { // Bit 0 - BG Display (gbmono mode) (0=Off, 1=On)
				for(int i=0; i<8; ++i) {
					int x = pixpos+i;
					if((x>=0)&&(x<160)) {
						DRAWPIX(x, 0, 0);
						zbuffer[x]=0;
					}
				}
			}
			else {
				// Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
				int WindowTileMap = ((LCDC&(1<<6))==0) ? 0x1800 : 0x1c00;
				// Bit 4 - BG & Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
				int TileData = ((LCDC&(1<<4))==0) ? 0x0800 : 0x0000;
				// Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
				int BGTileMap  = ((LCDC&(1<<3))==0) ? 0x1800 : 0x1c00;

				int bgline = SCY + LY;
				//NOTE: (((bgline&0xff)>>3)<<5) == ((bgline&0xf8)<<2);
				int bgtilemapindex = (((SCX+pixpos)&0xff)>>3)+((bgline&0xf8)<<2); // Index into BG tilemap
				int bgtile = VRAM[ BGTileMap + bgtilemapindex ];
				int bgpal  = 0x08 << 2; // NOTE: Will be used for GBC bg pallete later on

// 				int wndline = WY + LY;
// 				int wndtilemapindex = ;
// 				int wndtile = VRAM[ WindowTileMap + wndtilemapindex ];

				if(((LCDC&(1<<4))==0)) {  // Tiles in 8000-8FFF are numbered -128 to 127
					// Some magix to convert -128..127 to 0..255 and fix the index into patpix... somehow
					// FIXME: Explain this
					bgtile ^= 0x80;
					bgtile += 0x80;
				}
				int[] patLine = patpix[bgtile][bgline&7];
				for(int i=0; i<8; ++i) {
					int x = pixpos+i;
					if((x>=0)&&(x<160)) {
						DRAWPIX(x, bgpal, patLine[i]);
						zbuffer[x] = patLine[i];
					}
				}
			}
			cyclesToRender-=8;
			pixpos+=8;
		}
		cyclepos -= cyclesToRender;

		if(pixpos>=159) { // We're done with the background, now render the sprites on top
			int pricol = 0xff0000;
			boolean spr8x16 = ((LCDC&(1<<2))!=0);
			for(int curSprite = spriteCountOnScanline-1; curSprite>=0; --curSprite) { // Renders backwards for priorities in gb mono mode
// 			for(int curSprite = 0; curSprite<spriteCountOnScanline; ++curSprite) {
				if(!isCGB) {
					// In GB-mono mode sprites are ordered according to X coordinate,
					// e.g. left-most sprite on top of everything to it's right.
					// The exception is when two sprites have the same X coordinate,
					// in which case the sprite with the lowest OAM address has
					// priority.
					int line = LY - (OAM[spritesOnScanline[curSprite]] - 16);
					int xpos = OAM[spritesOnScanline[curSprite]|1]-8;
					int tile = OAM[spritesOnScanline[curSprite]|2];
					int attr = OAM[spritesOnScanline[curSprite]|3];
					if (spr8x16) {
						// Select the correct tile depending on whether we need to render the upper or lower part of the sprite
						tile &= ~1;
						tile |= (line >= 8) ? 1 : 0;
						line &= 7;
					}
					boolean priority = ((attr&(1<<7))==0); // True if sprite is above BG and window
					if((attr&(1<<6))!=0) line = 7 - line;  // Sprite is flipped vertically
					if((attr&(1<<5))!=0) tile |= (1<<10);  // Sprite is flipped horizontally
					int pallette = ((attr>>4)&1) << 2;            // Selects between OBP0 or OBP1
					int[] patLine = patpix[tile][line];    // Fetch a line from the tile buffer
					for(int i=0; i<8;++i) {                // And copy it to the screen.
						int color = patLine[i];              // Color 0 is always transparent
// 						if(color==0) color=(spritesOnScanline[curSprite]>>2)&3;
						if((xpos>=0) && (xpos<160) && (color!=0) && ((zbuffer[xpos]==0) || priority)) {
							DRAWPIX(xpos, pallette, color);
// 							switch(LY&0x3) {
// 								case 0:
// 								case 1:
// 									blitLine[xpos] = pricol;
// 									break;
// 								case 2:
// 								case 3:
// 									blitLine[xpos] = 0x0000ff + 0xff00/168*(168-OAM[spritesOnScanline[curSprite]|1]);
// 									break;
//
// 							}
						}
						++xpos;
					}
					pricol+=0x1600;
				}
				else {
					// In GB-color mode sprites are ordered according to their position
					// in the OAM, eg sprites with lower numbers on top of sprites with higher numbers
// 					PRINTLN("Sprite!");
				}
			}
// 			PRINTLN("");
		}
	}

	static int spriteCountOnScanline; // How many sprites there are on the current scanline
	static int[] spritesOnScanline = new int[40]; // Index into OAM, at most 10 sprites/scanline
	private static int setSpritesOnScanline() {
		int sprYSize = ((LCDC&(1<<2))!=0)?16:8;
		int count = 0;
		// NOTE: We store the sprites in OAM table order.
		//       This is important for CGB priorities and DMG X-X collisions
		for (int spr = 0; (spr < 40*4); spr+=4) { //NOTE: max sprites/scanline == 10
			int sprPos = LY - (OAM[spr] - 16); // Relative position of sprite top to current scanline
			//check if sprite is visible on this scanline (X position does not matter)
			//fixme: spriteX>168 should not ++count as it does currently.
			//       May they should count since gbspec.txt mention this??
			if((sprPos >= 0) && (sprPos < sprYSize )) {
				spritesOnScanline[count] = spr;
				++count;
			}
		}

		// In GB-mono mode sprites are ordered according to X coordinate,
		// e.g. left-most sprite displays on top of everything to it's right.
		// In GB-color mode sprites are ordered according to their position
		// in the OAM, e..g sprites with lower index on top of sprites with
		// higher index.
		// NOTE: This should be a stable sorting algorithm! (DMG sprite
		//       priorities rely on the order in OAM ram for sprites with
		//       equal X-coordinates.)
		if(!isCGB) {
			// Bubblesort ftw!
			for(int i=count-1; i>=0; --i) {
				for(int j=i-1; j>=0; --j) {
					if(OAM[spritesOnScanline[j]|1] > OAM[spritesOnScanline[i]|1]) {
						/* Swap with a triple XOR */
						//spritesOnScanline[i] ^= spritesOnScanline[j];
						//spritesOnScanline[j] ^= spritesOnScanline[i];
						//spritesOnScanline[i] ^= spritesOnScanline[j];

						// TODO: Which is faster?

						/* Swap with a temporary */
						int tmp = spritesOnScanline[i];
						spritesOnScanline[i] = spritesOnScanline[j];
						spritesOnScanline[j] = tmp;
					}
				}
			}
		}

		// Actually this is more complex than this, the actual number of sprites
		// displayed depends on how much of each sprite is present on each scan
		// line with >10 sprites (did not find an exact description of how this
		// works yet though)
		spriteCountOnScanline = (count > 10) ? 10 : count;
		return count;
	}


	public static int read(int index) {
		if(index < 0xa000) {
			if(allow_writes_in_mode_2_3 || ((LCDC&0x80)==0) || ((STAT&3)!=3))
				return VRAM[index-0x8000+CurrentVRAMBank];
			PRINTLN("WARNING: Read from VRAM["+STRFORMAT("0x%04x",index)+"] denied during mode "+(STAT&3)+", PC="+STRFORMAT("0x%04x",(CPU.getPC())));
			return 0xff;
		}
		if((index>0xfdff) && (index<0xfea0)) {
			if(allow_writes_in_mode_2_3 || ((LCDC&0x80)==0) || ((STAT&2)==0))
				return OAM[index-0xfe00];
			PRINTLN("WARNING: Read from OAM["+STRFORMAT("0x%04x",index)+"] denied during mode "+(STAT&3)+", PC="+STRFORMAT("0x%04x",(CPU.getPC())));
			return 0xff;
		}
		int b = 0xff;
		switch(index&0x3f) {
			case 0x00: // 0xff40 - LCDC register
				b = LCDC;
				break;
			case 0x01: // 0xff41 - STAT - LCDC Status (R/W)
				//FIXME: Needs verification: (see VC.render() notes on disabling the LCD)
				//       (I don't really believe this though ...)
				b = ((LCDC&0x80)==0) ? (STAT&0x7c)|0x00 : STAT; //Stay in hblank when disabled
				b = STAT | 0x80;
				break;
			case 0x02: // 0xff42 - SCY
				b = SCY;
				break;
			case 0x03: // 0xff43 - SCX
				b = SCX;
				break;
			case 0x04: // 0xff44 - LY
				/* FIXME: Needs verification: (see VC.render() notes on disabling the LCD)
					*       (I don't really believe this though as it appears to break at least
					*       Escape From Camp Deadly and Street Fighter II ...)
					*/
				b = ((LCDC&0x80)==0) ? 0 : LY; //Stay on scanline 0 when disabled
// 						b = VC.LY;
				break;
			case 0x05: // 0xff45 - LYC
				b = LYC;
				break;
			case 0x07: // 0xff47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only
			case 0x08: // 0xff48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only
			case 0x09: // 0xff49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only
				b = CPU.IOP[index-0xff00]; // FIXME: according to gmb-spec.txt these are write only ("Reads always 00")
				break;
			case 0x0a: // 0xff4a - WY
				b = WY;
				break;
			case 0x0b: // 0xff4b - WX
				b = WX;
				break;
			case 0x0d: // 0xff4d - KEY1 - CGB Mode Only - Prepare Speed Switch
				b = CPU.doublespeed ? (1<<7) : 0;
				break;
			case 0x0f: // 0xff4f - VRAM bank nr
				b = getcurVRAMBank();
				break;
			case 0x11: // 0xff51 - FF51 - HDMA1 - CGB Mode Only - New DMA Source, High
			case 0x12: // 0xff52 - FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low
			case 0x13: // 0xff53 - FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High
			case 0x14: // 0xff54 - FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low
			case 0x15: // 0xff55 - FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start
				b = CPU.IOP[index-0xff00];
				break;
			case 0x28: // 0xff68 - BGPI
				b = BGPI;
				break;
			case 0x29: // 0xff69 - BGPD
				b = getBGColData();
				break;
			case 0x2a: // 0xff6a - OBPI
				b = OBPI;
				break;
			case 0x2b: // 0xff6b - OBPD
				b = getOBColData();
				break;
			case 0x2c: // 0xff6c - Undocumented (FEh) - bit 0 (Read/Write)
				PRINTF("WARNING: VC.read(): Read from *undocumented* IO port $%04x\n", index);
					b = CPU.IOP[index-0xff00] | 0xfe;
				break;
			default:
				PRINTF("TODO: VC.read(): Read from IO port $%04x\n", index);
		}
		return b;
	}

	public static void write(int index, int value) {
		if(index < 0xa000) { // VRAM: 0x8000 - 0x9fff, lowest writeable address in VC (checked in CPU.write)
			if(allow_writes_in_mode_2_3 || ((LCDC&0x80)==0) || ((STAT&3)!=3)) {
				VRAM[index-0x8000+CurrentVRAMBank]=value;
				patdirty[(CurrentVRAMBank>>4)+((index-0x8000)>>4)] = true; // nicked from gnuboy...
				anydirty = true;
				return;
			}
			PRINTLN("WARNING: Write to VRAM["+STRFORMAT("0x%04x",index)+"] denied during mode "+(STAT&3)+", PC="+STRFORMAT("0x%04x",(CPU.getPC())));
			return;
		}
		if((index > 0xfdff) && (index<0xfea0)) { // OAM: 0xfe00 - 0xfe9f
			if(allow_writes_in_mode_2_3 || ((LCDC&0x80)==0) || ((STAT&2)==0)) {
				OAM[index-0xfe00]=value;
				return;
			}
			PRINTLN("WARNING: Write to OAM["+STRFORMAT("0x%04x",index)+"] denied during mode "+(STAT&3)+", PC="+STRFORMAT("0x%04x",(CPU.getPC())));
			return;
		}
		switch(index&0x3f) { // VC: 0xff40 - 0xff6f
			case 0x00: // 0xff40 - LCDC register
				if( ((value&0x80)!=0) && ((LCDC&0x80)==0) ) restart();
				LCDC = value;
				break;
			case 0x01: // 0xff41 - STAT - LCDC Status (R/W)
				STAT = (STAT&0x87)|(value&0x78); //lower 3bits are readonly
				ISTAT = STAT; // reset ISTAT to STAT (bits 6-3 only)
				ISTAT_mask = 0xff;
				if (!isCGB && ((STAT & 2)==0) && ((LCDC&0x80)!=0)) {
					/* DMG STAT write bug => interrupt
					* In certain situations, writing to the STAT register ($ff41) seems to cause bit 1
					* of the IF register ($ff0f) to be set (and thus cause interrupt $48 to occur, if
					* it is enabled). Due to programming bugs, at least two games (Roadrash, Legend of
					* Zerd) insist on this quirk, and are incompatible with the GBC. As far as has been
					* figured out, the bug happens everytime ANYTHING (including 00) is written to the
					* STAT register ($ff41) while the gameboy is either in HBLANK or VBLANK mode. It
					* doesn't seem to happen when the gameboy is in OAM or VRAM mode, or when the display
					* is disabled. (Info from Martin Korth.)
					*/
					// FIXME: Does this clear any flags from ISTAT? Atm it
					// does not, (we clears ISTAT_mask above).
					// See also CPU.checkInterrupts().
					CPU.triggerInterrupt(1);
				}
				break;
			case 0x02: // 0xff42 - SCY
				if(useSubscanlineRendering)
					renderScanlinePart();
				SCY = value;
				break;
			case 0x03: // 0xff43 - SCX
				if(useSubscanlineRendering)
					renderScanlinePart();
				SCX = value;
				break;
			case 0x04: // 0xff44 - LY
				LY = 0; // can only be set to 0
				break;
			case 0x05: // 0xff45 - LYC
				// We're not sure if this is correct or not, but at least it fixes flickering
				// in donkey kong by allowing to generate an STAT interrupt as soon as LY equals
				// LYC, instead of on the next mode0->mode2 transition.
				// The pandocs state that:
				//   "The gameboy permanently compares the value of the LYC and LY registers.
				//    When both values are identical, the coincident bit in the STAT register
				//    becomes set, and (if enabled) a STAT interrupt is requested."
				// But they make a habit of writing 'permanently' where they mean 'continually'.
				STAT &= ~(1<<2); // Clear Coincidence bit
				if (LYC != value && LY==value && (STAT&(1<<6))!=0) {
					STAT |= (1<<2); // Set Coincidence bit
					CPU.triggerInterrupt(1);
					ISTAT_mask &= 0x7f; // Clear all bits above bit 6
				}
				LYC = value;
				break;
			case 0x06:{ // 0xff46 - DMA - DMA Transfer and Start Address (W)
				//NOTE: CPU may only access HRAM during this DMA,
				//      so there is no need to do special timing
				CPU.last_memory_access=CPU.last_memory_access_internal;
				//ASSERT((STAT&2)==0);
				for(int i=0; i<0xa0; ++i){
					CPU.write(0xfe00|i, CPU.read(i+(value<<8)));
				}
				CPU.last_memory_access_internal=CPU.last_memory_access;
				} break;
			case 0x07: // 0xff47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only
			case 0x08: // 0xff48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only
			case 0x09: // 0xff49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only
				if(useSubscanlineRendering)
					renderScanlinePart();
				CPU.IOP[index-0xff00] = value;
				updateMonoColData(index-0xff47);
				break;
			case 0x0a: // 0xff4a - WY
				WY = value;
				break;
			case 0x0b: // 0xff4b - WX
				WX = value;
				break;
			case 0x0d: // 0xff4d - KEY1 - CGB Mode Only - Prepare Speed Switch
				CPU.speedswitch = ((value&1)!=0);
				break;
			case 0x0f: // 0xff4f - VBK - CGB Mode Only - VRAM Bank
				selectVRAMBank(value&1);
				break;
			case 0x11: // 0xff51 - HDMA1 - CGB Mode Only - New DMA Source, High
			case 0x12: // 0xff52 - HDMA2 - CGB Mode Only - New DMA Source, Low
			case 0x13: // 0xff53 - HDMA3 - CGB Mode Only - New DMA Destination, High
			case 0x14: // 0xff54 - HDMA4 - CGB Mode Only - New DMA Destination, Low
				CPU.IOP[index-0xff00] = value;
				break;
			case 0x15: // 0xff55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start
				int mode = ((CPU.hblank_dma_state|value) & 0x80);
				if (mode == 0) {
					int src = ((CPU.IOP[0x51]<<8)|CPU.IOP[0x52]) & 0xfff0;
					int dst = (((CPU.IOP[0x53]<<8)|CPU.IOP[0x54]) & 0x1ff0) | 0x8000;
					int len = ((value & 0x7f)+1)<<4;
					PRINTLN("WARNING: CPU.write(): TODO: Untimed H-DMA Transfer");
					// TODO: this should take more than 4-12 cycles :O
					//PRINTF("DONE: General HDMA transfer src=$%04x dst=$%04x len=$%04x\n", src, dst, len);
					for (int i = 0; i < len; ++i)
						write(dst++, CPU.read(src++));
					CPU.IOP[0x51] = src >> 8;
					CPU.IOP[0x52] = src & 0xF0;
					CPU.IOP[0x53] = 0x1F & (dst >> 8);
					CPU.IOP[0x54] = dst & 0xF0;
					CPU.IOP[0x55] = 0xff; // indicate we have finished
//					elapseTime();// Add elapsed time to counters (CPU was stalled, not time!) //FIXME:WIP
				} else {
					CPU.hblank_dma_state = value;
					CPU.IOP[0x55] = value & 0x7f;
				}
				break;
			case 0x28: // 0xff68 - BGPI
				BGPI = value;;
				break;
			case 0x29: // 0xff69 - BGPD
				setBGColData(value);
				break;
			case 0x2a: // 0xff6a - OBPI
				OBPI = value;;
				break;
			case 0x2b: // 0xff6b - OBPD
				setOBColData(value);
				break;
			case 0x2c: // 0xff6c - Undocumented (FEh) - bit 0 (Read/Write)
				PRINTF("WARNING: VC.write(): Write %02x to *undocumented* IO port $%04x\n",value, index);
					CPU.IOP[index-0xff00] = value;
				break;
			default:
				PRINTF("TODO: VC.write(): Write %02x to IO port $%04x\n",value, index);
				break;
		}
	}

	public static void selectVRAMBank(int i) {
		CurrentVRAMBank=i*0x2000;
		if ((i <0) || (i > 1))
			PRINTF("current offset=%x\n",CurrentVRAMBank);
	}

	public static int getcurVRAMBank() {
		return CurrentVRAMBank/0x2000;
	}

	/* rendering of scanline starts here */
	// some global vars for render procedure
	// not thread-safe, who cares!
	private static int TileData;
	private static int BGTileMap;
	private static int WindowTileMap;
	private static int bgY;
	private static int bgTileY;
	private static int bgOffsY;
	private static int bgX;
	private static int bgTileX;
	private static int bgOffsX;
	private static int windX;
	private static int tilebufBG[] = new int[0x300]; // ? max here could be lower?
	private static BLITPIXTYPE[] blitLine;

#define DRAWPIX_S(x, pal, col) DRAWPIX(x, (pal << 2), col)

	// NOTE: Renders one scanline. It is important to ensure that this is called
	//       exactly once for each scanline (and no more!), or curBGY and
	//       curWNDY will overflow.
	public static void renderScanline() {
		/* FF40 - LCDC - LCD Control (R/W)
		* Bit 7 - LCD Display Enable             (0=Off, 1=On)
		* Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
		* Bit 5 - Window Display Enable          (0=Off, 1=On)
		* Bit 4 - BG & Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
		* Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
		* Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
		* Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
		* Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)
		*/
		if (cfskip != 0) return;
		if((LCDC&(1<<7))!=0) { //LCD enabled

			updatepatpix();

			blitLine = blitImg[LY];

			TileData = ((LCDC&(1<<4))==0) ? 0x0800 : 0x0000;
			BGTileMap = ((LCDC&(1<<3))==0) ? 0x1800 : 0x1c00;
			WindowTileMap = ((LCDC&(1<<6))==0) ? 0x1800 : 0x1c00;

			windX = 160;
			if(((LCDC&(1<<5))!=0)			 //window display enabled
			&& (WX >= 0) && (WX < 167) // yes this is 160+7
			&& (WY >= 0) && (WY < 144)
			&& (LY >= WY))
				windX = (WX - 7);         // [-8 < wndX < 160]

			renderScanlineBG();

			if (windX < 160) { // window doesnt have height, width
				renderScanlineWindow();
			}

			if((LCDC&(1<<1))!=0) { // sprites enabled
				renderScanlineSprites();
			}
		}
	}

	//private int lbgTileY = -1;

	private static void calcBGTileBuf() {
		/*	not really 100% correct...
				if (lbgTileY==bgTileY)
			return;
		lbgTileY=bgTileY;
		*/
		int tileMap = BGTileMap + bgTileX + (bgTileY*32);
		int attrMap = tileMap + 0x2000;
		int bufMap  = 0;
		int cnt     = ((windX+7) >> 3) + 1;

		for (int i = 0; i < cnt; ++i) {
			int tile = VRAM[tileMap++];
			int attr = VRAM[attrMap++];
			if (TileData == 0x0800) {
				tile ^= 0x80;
				tile += 0x80;
			}
			tilebufBG[bufMap++] = tile |
			 ((attr & 0x08) << 6) |              // bank select
			 ((attr & 0x60) << 5);               // horiz/vert flip
			tilebufBG[bufMap++] = ((attr&7) | 0x08) << 2; // pal select                   xpppcc
			int priority = 1;
			if(isCGB) {
				// Either increase priority to 2, or drop it to 0
				// attr.7 unset = use sprite prio bit, set = bg on top
				// LCDC.0 unset = sprites always on top
				priority += ((attr>>7)&1);
				priority *= (LCDC&(1<<0));
			}
			tilebufBG[bufMap++] = priority;
			if ((tileMap&31)==0) { //if ((attrMap&31)==0)
				tileMap -= 32;
				attrMap -= 32;
			}
		}
	}

	private static void renderScanlineBG() {
		int bufMap = 0;
		int cnt = windX;
		if (cnt == 0) return;

		if(!isCGB && (LCDC&(1<<0)) == 0) { // Background disabled
			for(int i=0; i<cnt; ++i) {
				//DRAWPIX(i, TilePal, PatLine[t]);
				zbuffer[i] = 0; // fixme: not sure what happens to prio when bg is off
				blitLine[i] = 0xff00ff; // TODO: Find a way to output the 'lcd off' color independenly of palette
			}
			return;
		}

		bgY     = (SCY+LY)&0xFF;
		bgTileY = bgY >> 3;
		bgOffsY = bgY & 7;
		bgX     = SCX; // it wraps, too
		bgTileX = bgX >> 3; // tile x
		bgOffsX = bgX & 7; // x offs

		calcBGTileBuf();

		int tileMap   = BGTileMap + bgTileX + (bgTileY*32) + 0x2000;
		int PatLine[] = patpix[tilebufBG[bufMap++]][bgOffsY];
		int TilePal   = tilebufBG[bufMap++];
		int priority  = tilebufBG[bufMap++];
		int curX      = 0;

		for (int t = bgOffsX; t < 8; ++t, --cnt) {
			zbuffer[curX] = (PatLine[t] == 0) ? 0 : priority;
			DRAWPIX(curX++, TilePal, PatLine[t]);
		}

		if (cnt == 0) return;

		while (cnt>=8) {
			PatLine  = patpix[tilebufBG[bufMap++]][bgOffsY];
			TilePal  = tilebufBG[bufMap++];
			priority = tilebufBG[bufMap++];
			for (int t = 0; t < 8; ++t) {
				zbuffer[curX] = (PatLine[t] == 0) ? 0 : priority;
				DRAWPIX(curX++, TilePal, PatLine[t]);
			}
			cnt -= 8;
		}
		PatLine  = patpix[tilebufBG[bufMap++]][bgOffsY];
		TilePal  = tilebufBG[bufMap++];
		priority = tilebufBG[bufMap++];
		for (int t = 0; cnt > 0; --cnt, ++t) {
			zbuffer[curX] = (PatLine[t] == 0) ? 0 : priority;
			DRAWPIX(curX++, TilePal, PatLine[t]);
		}
	}

	private static void calcWindTileBuf() {
		int tileMap = WindowTileMap + (bgTileY*32);
		int attrMap = tileMap + 0x2000;
		int bufMap = 0;
		int cnt = ((160-(windX+7)) >> 3) + 2;

		for (int i = 0; i < cnt; ++i) {
			int tile = VRAM[tileMap++];
			//PRINTF("attrMap=0x%04x, tilemap=0x%04x, WindowTileMap=0x%04x, bgTileY=0x%04x\n", attrMap, tileMap, WindowTileMap, bgTileY);
			int attr = VRAM[attrMap++];
			if (TileData == 0x0800) {
				tile ^= 0x80;
				tile += 0x80;
			}
			tilebufBG[bufMap++] = tile |
			 ((attr & 0x08) << 6) |              // bank select
			 ((attr & 0x60) << 5);               // horiz/vert flip
			tilebufBG[bufMap++] = ((attr&7) | 0x8) << 2; // pal select
			int priority = 1;
			if(isCGB) {
				// Either increase priority to 2, or drop it to 0
				// attr.7 unset = use sprite prio bit, set = bg on top
				// LCDC.0 unset = sprites always on top
				priority += ((attr>>7)&1);
				priority *= (LCDC&(1<<0));
			}
			tilebufBG[bufMap++] = priority;
			if ((tileMap&31)==0) { //if ((attrMap&31)==0)
				tileMap -= 32;
				attrMap -= 32;
			}
		}
	}

	private static void renderScanlineWindow() {
		int bufMap = 0;
		int curX = MAX(windX,0);
		int cnt = 160-curX;
		if (cnt == 0)
			return;
		bgY     = curWNDY++;
		bgTileY = bgY >> 3;
		bgOffsY = bgY & 7;

		bgOffsX = curX - windX;

		calcWindTileBuf();

		int PatLine[] = patpix[tilebufBG[bufMap++]][bgOffsY];
		int TilePal = tilebufBG[bufMap++];
		int priority  = tilebufBG[bufMap++];

		for (int t = bgOffsX; (t < 8) && (cnt > 0); ++t, --cnt) {
			zbuffer[curX] = (PatLine[t] == 0) ? 0 : priority;
			DRAWPIX(curX++, TilePal, PatLine[t]);
		}

		while (cnt>=8) {
			PatLine = patpix[tilebufBG[bufMap++]][bgOffsY];
			TilePal = tilebufBG[bufMap++];
			priority = tilebufBG[bufMap++];
			for (int t = 0; t < 8; ++t) {
			zbuffer[curX] = (PatLine[t] == 0) ? 0 : priority;
				DRAWPIX(curX++, TilePal, PatLine[t]);
			}
			cnt -= 8;
		}
		PatLine = patpix[tilebufBG[bufMap++]][bgOffsY];
		TilePal = tilebufBG[bufMap++];
		priority = tilebufBG[bufMap++];
		for (int t = 0; cnt > 0; --cnt, ++t)  {
			zbuffer[curX] = (PatLine[t] == 0) ? 0 : priority;
			DRAWPIX(curX++, TilePal, PatLine[t]);
		}
	}

	private static void renderScanlineSprites() {
		// NOTE: spritesOnScanline[] should be set by the render() by
		//       calling setSpritesOnScanline() during mode 2/3.
		//       setSpritesOnScanline() ensures that the first 10 sprites
		//       in spritesOnScanline[] are the selected sprites for display,
		//       in order of increasing priority.
		boolean spr8x16 = ((LCDC&(1<<2))!=0);
		// loop starts with highest priority sprite
		for (int spr = 0; spr < spriteCountOnScanline; ++spr) {
			int line = LY - OAM[spritesOnScanline[spr]] + 16;
			int xpos = OAM[spritesOnScanline[spr]|1]-8;
			int tile = OAM[spritesOnScanline[spr]|2];
			int attr = OAM[spritesOnScanline[spr]|3];
			int priority = 1 - ((attr>>7)&1); // attr.7 unset = sprite is above BG and window

			int from  = xpos < 0 ? 0 : xpos;
			int pixel = from - xpos;
			int until = xpos > 160-8 ? 160 : xpos+8;

			if (from >= until)
				continue;

			if ((attr&(1<<6))!=0) // Sprite is flipped vertically
				line = (spr8x16 ? 15 : 7) - line;
			if (spr8x16) {
				// Select the correct tile depending on whether we need
				// to render the upper or lower part of the sprite
				tile &= ~1;
				tile |= (line >= 8) ? 1 : 0;
				line &= 7;
			}

			if ((attr&(1<<5))!=0) // Sprite is flipped horizontally
				tile |= (1<<10);

			int pallette;
			if (isCGB) {
				if ((attr&(1<<3))!=0) // bank select
					tile |= (1<<9);
				pallette = (attr & 7) << 2 ;
			} else
				pallette = ((attr>>4)&1) << 2; // Selects between OBP0 or OBP1

			int[] patLine = patpix[tile][line]; // Fetch a line from the tile buffer

			while (from < until) {
				int color = patLine[pixel];
				if (color != 0) {
					// Color 0 is always transparent
					// zbuffer == 0 -> color 0, sprite goes on top
					// zbuffer == 1 -> use sprite prio
					// zbuffer == 2 -> bg has prio, sprites goes behind
					// zbuffer == 3 -> sprite with higher priority has drawn this pixel
					if (priority >= zbuffer[from])
						DRAWPIX(from, pallette, color);

					// Even if we didn't draw a pixel because of bg priority
					// we still mark the zbuffer as if we did, this will make
					// high priority sprites below the bg override appear to
					// 'takes on the colors of the background'
					zbuffer[from] = 3; // shouldn't this be outside the if!=0
				}
				++from;
				++pixel;
			}
		}
	}
}
#endif
