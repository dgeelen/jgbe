#include "Global.inc"
#include "SaveLoad.inc"
#include "CPU.inc"

#ifdef USE_JAVA_MOBILE
#define VideoController MobileVideoController
#endif

#ifndef USE_JAVA_MOBILE
import java.net.*;
import java.util.zip.*;
import java.util.ArrayList;
#endif

public final class CPU {
		public static CPU singleton = null;

		//FLAGS
		public static final int ZF_Shift = 7;
		public static final int NF_Shift = ZF_Shift - 1;
		public static final int HC_Shift = NF_Shift - 1;
		public static final int CF_Shift = HC_Shift - 1;
		public static final int ZF_Mask  = 1 << ZF_Shift;
		public static final int NF_Mask  = 1 << NF_Shift;
		public static final int HC_Mask  = 1 << HC_Shift;
		public static final int CF_Mask  = 1 << CF_Shift;

		public static final long MAX_CYCLE_COUNT = 0x7FFFFFFFFFFFFFFFL; // 2^63 - 1

		public static long TotalInstrCount = 0;
		public static long TotalCycleCount = 0;

		public static long NextEventCycleCount = 0; // cyclecount when next event should happen (next time TIMA would overflow)
		public static long VCRenderEventCycleCount = 0; // cyclecount when VC needs to render something again
		public static long lastVCRenderCycleCount = 0; // cyclecount when VC last rendered something
		public static long KeyBounceEventCycleCount = 0; // cyclecount when next keybounce event should happen
		public static long TIMAEventCycleCount = 0; // cyclecount when next TIMA event should happen
		public static int cyclesPerTIMA = 0; //number of cycles per TIMA increase, or 0 when TIMA is disabled
		public static int keyBounce = 0;

		public static boolean KeyBounceEventPending = false;
		public static boolean TIMAEventPending = false;

		public static int A = 0;
		public static int B = 1;
		public static int C = 2;
		public static int D = 3;
		public static int E = 4;
		public static int F = 5;
		public static int H = 6;
		public static int L = 7;

		public static int[] IOP = new int[0x80]; //IO Ports
		public static BTYPE[] HRAM = new BTYPE[0x7f]; //HighRAM
		public static BTYPE[][] WRAM = new BTYPE[0x08][0x1000]; //8x4k InternalRAM
		public static BTYPE[] FWRAM = WRAM[0]; // first WRAM bank, this is the placa almost aways used for the stack
		public static int CurrentWRAMBank=1;

		public static boolean doublespeed = false;
		public static boolean speedswitch = false;

		// same in single and double speed:
		public static final int CYCLES_PER_DIV = 256;
		public static long divReset = 0;

		public static int globalPC = 0;
		public static int localPC = 0;

		public static BTYPE[] smallcruise = new BTYPE[2];
		public static BTYPE[] decoderMemory = null;
		public static int decoderMaxCruise = 0;

		public static int getPC() {
			return globalPC + localPC;
		}

		public static void setPC(int newPC) {
			newPC &= 0xffff;
			if (rMemMap[newPC >> 12] != null && (newPC&0x0fff)<=(0x0fff-2)) {
				//PRINTLN("Memmap cruise: " + newPC);
				decoderMemory = rMemMap[newPC >> 12];
				globalPC = newPC&0xf000;
				localPC = newPC&0x0fff;
				decoderMaxCruise = 0x0ffe;
			} else if (0xFF80 <= newPC && newPC <= 0xFFFE-2) {
				//PRINTLN("HRAM cruise: " + newPC);
				localPC = newPC - 0xFF80;
				globalPC = newPC - localPC;
				decoderMemory = HRAM;
				decoderMaxCruise = 0x7d;
			} else {
				//PRINTLN("Failed cruise: " + newPC);
				smallcruise[0] = I2B(read(newPC));
				// We need to save & restore the state of the BIOS ROM, because
				// we are doing a read-ahead here. Otherwise we end up disabling
				// the BIOS one instruction too early, which causes most ROMs
				// to enter an RST &38 loop when the BIOS is disabled while
				// it is executing, instead of using the NOP trick (See Bios.jpp)
				// to proceed to the game rom.
				// If performance is an issue we could also connect a signal
				// to the GUI telling it to disable the BIOS on/off control
				// while the bios is running.
				boolean b = BIOS_enabled;
				smallcruise[1] = I2B(read((newPC+1)&0xffff));
				if(b) {
					rMemMap[0x0] = null;
					BIOS_enabled = b;
				}
				decoderMemory = smallcruise;
				decoderMaxCruise = 0; // still set to zero, to get memory reread as late as possible
				globalPC = newPC;
				localPC = 0;
			}
		}

		public static void pushPC() {
			int pc = globalPC + localPC;
			if (SP >= 0xC002 && SP <= 0xD000) {
				FWRAM[--SP - 0xC000] = I2B(pc>>8);
				FWRAM[--SP - 0xC000] = I2B(pc&0xff);
			} else slowPushPC();
		}

		public static void slowPushPC() {
			//PRINTLN("SLOW PUSH: "+ SP);
			int pc = globalPC + localPC;
			--SP; SP &= 0xffff; write(SP, pc >> 8);
			--SP; SP &= 0xffff; write(SP, pc&0xff);
		}

		public static void popPC() {
			if (SP >= 0xC000 && SP <= 0xCFFE	) {
				setPC(
					   B2I(FWRAM[SP++ - 0xC000])
					+ (B2I(FWRAM[SP++ - 0xC000])<<8)
				);
			} else slowPopPC();
		}

		public static void slowPopPC() {
			//PRINTLN("SLOW POP: "+ SP);
			int pc = read(SP++);     SP &= 0xffff;
			pc |= (read(SP++) << 8); SP &= 0xffff;
			setPC(pc);
		}

		//public static int PC=0;         ///< Program counter
		public static int SP=0;         ///< Stack Pointer
		public static int IE=0;         ///< Interrupt Enable (allowed interrupts)
		public static boolean IME=true; ///< Interrupt Master Enable
		public static boolean halted=false;
		public static boolean delayed_halt=false;
		public static boolean halt_fail_inc_pc=false;

		//IO
		public static int KeyStatus=0; //bitmask, low 4=direction, upper 4=start,select,a,b, inverted from GameBoy POV
		public static int GUIKeyStatus=0;
		public static int RemoteKeyStatus=0;
		public static boolean useRemoteKeys = false;

		public static boolean keyHistoryEnabled;
		public static IntVector keyHistory;
		public static int lastKeyChange;
		public static int playbackHistoryIndex = -1;

		static boolean BIOS_enabled = false;

		//CPU Class variables
		public static Cartridge cartridge;// = new Cartridge("Pokemon Blue.gb");
		#ifndef USE_JAVA_MOBILE
			public static Disassembler deasm;
		#endif
		public static VideoController VC;
		public static AudioController AC;
		static int hblank_dma_state;
		//Debug helpers
		public static int last_memory_access=-1;
		public static int last_memory_access_internal=-1;

		public CPU() {
			PRINTFREEMEM("CPU() - 1");
			if (singleton != null) {
				PRINTLN("WARNING: trying to instantiate second instance of CPU singleton class");
				//int x[]=null;
				//x[0] = 0;
			}
			singleton = this;
			#ifndef USE_JAVA_MOBILE
				deasm = new Disassembler(this, Disassembler.SIMPLE_DISASSEMBLY);
			#endif
			PRINTFREEMEM("CPU() - 2");
			VC = new VideoController(this, 160, 144);
			PRINTFREEMEM("CPU() - 3");
			AC = new AudioController(this);
			PRINTFREEMEM("CPU() - 4");
			keyHistory = new IntVector();
			PRINTFREEMEM("CPU() - 5");
			cartridge = null;
			PRINTFREEMEM("CPU() - 6");
			//rccache[0x2cbb] = CPURecompiler.Recompile(0x2cbb);
		}

		public static void loadCartridge(Cartridge acartridge) {
			cartridge = acartridge;

			reset(false);

			//for (int i = 0; i < 0x4000; ++i)
			//	rccachea[0][i] = CPURecompiler.doRecompile(i);
		}

		public static boolean canRun() {
			return (cartridge != null);
		}

		public static String first_save_string = new String();
		public static String last_save_string = new String();

		public static void calcCyclesPerTIMA() {
			// 0-3 -> {1024, 16, 64, 256}
			// 0-3 -> 4*{256, 4, 16, 64}
			if ((IOP[0x07]&4) != 0) { // TIMA enabled
				cyclesPerTIMA = 4*(4 << (2 * ((IOP[0x07]-1)&3)));
			} else {
				cyclesPerTIMA = 0;
			}
		}

		public static void calcTIMAEventCycleCount() {
			if ((IOP[0x07]&4) != 0) { // TIMA enabled
				TIMAEventCycleCount = TotalCycleCount + cyclesPerTIMA * (0x100 - IOP[0x05]);
				addEventCycleCount(TIMAEventCycleCount);
				TIMAEventPending = true;
			} else {
				TIMAEventCycleCount = MAX_CYCLE_COUNT;
				TIMAEventPending = false;
			}
		}

		static SAVELOAD_FUNCTION {
			SL_IF_VERSION( 0,  9) first_save_string = "unknown";
			SL_IF_VERSION( 0,  9) last_save_string = "unknown";
			if (SL_SAVE) last_save_string = Version.str;
			SL_IF_VERSION(10, -1) SL_STRING(first_save_string);
			SL_IF_VERSION(10, -1) SL_STRING(last_save_string);

			SL_IF_VERSION( 1, -1) {
				SL_UINT8(B);
				SL_UINT8(C);
				SL_UINT8(D);
				SL_UINT8(E);
			}
			SL_UINT8(H);
			SL_UINT8(L);
			SL_UINT8(F);
			SL_UINT8(A);
			SL_ARR(UINT8, IOP, 0x80);
			SL_ARR(UINT8B, HRAM, 0x7f);
			SL_IF_VERSION( 0,  0) {
				boolean doskip = false;
				int skipsize = 0x10000 - 0x1000;
				
				SL_ARR(UINT8B, WRAM[0], 0x1000);
				if (SL_LOAD) {
					// some version 0 savegames have too much WRAM data, and some don't
					// try reading 0x8000 bytes, for savegames with too much data, these will all be zero
					// for other savegames, those are highly unlikely/impossible to be all zero
					int trysize = 0x8000;
					byte[] buffer = new byte[trysize];
					int len = distream.read(buffer, 0, trysize);
					if (len == trysize) {
						doskip = true;
						for (int i = 0; i < trysize; ++i)
							if (buffer[i] != 0)
								doskip = false;
					}
					if (!doskip)
						distream = new DataInputStream(new MSequenceInputStream(new ByteArrayInputStream(buffer), distream));
					else
						SL_SKIP(UINT8B, skipsize-trysize);
				}

				for (int i = 1; i < 8; ++i) {
					SL_ARR(UINT8B, WRAM[i], 0x1000);
					if (doskip) SL_SKIP(UINT8B, skipsize);
				}
			}
			SL_IF_VERSION( 1, -1) SL_ARR_2D(UINT8B, WRAM, 0x08, 0x1000);
			SL_INT(CurrentWRAMBank);
			SL_BOOL(doublespeed);
			SL_BOOL(speedswitch);

			int DIVcntdwnFix = -1; // is used below to fix up divReset
			SL_IF_VERSION( -1, 18) SL_INT(DIVcntdwnFix);
			SL_IF_VERSION( 19, -1) SL_LONG(divReset);
			int TIMAcntdwnFix = -1; // is used below to fix up TIMAResetCycleCount
			SL_IF_VERSION( -1, 19) SL_INT(TIMAcntdwnFix);
			SL_IF_VERSION( 20, -1) SL_LONG(TIMAEventCycleCount);

			SL_IF_VERSION( -1, 14) SL_SKIP(INT, 1); //SL_INT(LCDCcntdwn);
			SL_IF_VERSION( 21, -1) SL_LONG(lastVCRenderCycleCount);

			int pc = getPC();
			SL_UINT16(pc);
			setPC(pc);

			SL_UINT16(SP);
			SL_UINT8(IE);
			SL_BOOL(IME);
			SL_BOOL(halted);
			SL_IF_VERSION(16, -1) SL_BOOL(delayed_halt);
			SL_IF_VERSION(16, -1) SL_BOOL(halt_fail_inc_pc);
			SL_IF_VERSION( 0,  2) SL_SKIP(UINT8, 1); //SL_UINT8(DirectionKeyStatus);
			SL_IF_VERSION( 0,  2) SL_SKIP(UINT8, 1); //SL_UINT8(ButtonKeyStatus);
			SL_IF_VERSION(11, -1) SL_UINT8(KeyStatus);
			SL_IF_VERSION(12, -1) SL_INT(keyBounce);
			SL_IF_VERSION(22, -1) SL_LONG(KeyBounceEventCycleCount);
			int keyBounceWaitNextFix = 0;
			SL_IF_VERSION(12, 21) SL_INT(keyBounceWaitNextFix);
			SL_IF_VERSION(-1, 18) SL_SKIP(INT, 1); // SL_INT(lastException);
			SL_BOOL(BIOS_enabled);

			SL_OBJ(cartridge);
			SL_OBJ(VC);
			SL_IF_VERSION( 2, -1) SL_OBJ(AC);

			SL_IF_VERSION( 3, 13) SL_SKIP(UINT8, 1); // vcmode

			SL_IF_VERSION( 3,  8) SL_INT(TotalInstrCount);
			SL_IF_VERSION( 3,  8) SL_INT(TotalCycleCount);
			SL_IF_VERSION( 9, -1) SL_LONG(TotalInstrCount);
			SL_IF_VERSION( 9, -1) SL_LONG(TotalCycleCount);

			SL_IF_VERSION( 4, 16) SL_SKIP(UINT8, 1); //SL_UINT8(hw_ilines);

			SL_IF_VERSION( 7, -1) SL_UINT8(hblank_dma_state);

			SL_IF_VERSION(13, -1) {
				if (SL_SAVE && playbackHistoryIndex != -1) {
					boolean t = true;
					SL_BOOL(t);
					SL_INT(lastKeyChange);
					int olen = keyHistory.size();
					keyHistory.setSize(playbackHistoryIndex);
					SL_OBJ(keyHistory);
					keyHistory.setSize(olen);
				} else {
					SL_BOOL(keyHistoryEnabled);
					if (keyHistoryEnabled) {
						SL_INT(lastKeyChange);
						SL_OBJ(keyHistory);
					}
				}
				if (SL_LOAD) playbackHistoryIndex = -1;
			} else
				keyHistoryEnabled = false;

			if (SL_LOAD) {
				refreshMemMap();
				calcCyclesPerTIMA();
				NextEventCycleCount = 0;
				VCRenderEventCycleCount = 0;
				SL_IF_VERSION( -1,  2) {
					TotalInstrCount = 0;
					TotalCycleCount = 0;
				}
				SL_IF_VERSION( -1, 18) {
					// fix divReset for old savegames
					divReset = (TotalCycleCount + CYCLES_PER_DIV - 1) - (IOP[0x04]*CYCLES_PER_DIV);
					divReset -= CYCLES_PER_DIV;
					divReset += DIVcntdwnFix;
				}
				SL_IF_VERSION( -1, 19) {
					// fix TIMAEventCycleCount for old savegames
					calcTIMAEventCycleCount();
					TIMAEventCycleCount -= cyclesPerTIMA;
					TIMAEventCycleCount += TIMAcntdwnFix;
					addEventCycleCount(TIMAEventCycleCount);
				}
				SL_IF_VERSION( -1, 20)
					lastVCRenderCycleCount = TotalCycleCount;
				SL_IF_VERSION( -1, 21) // a bit fuzyy, see comments in handleKeyBounceEvent
					KeyBounceEventCycleCount = (keyBounce > 0) ? TotalCycleCount + keyBounceWaitNextFix * ((doublespeed)?10:20) : MAX_CYCLE_COUNT;
				SL_IF_VERSION( 22, 22) { // fix some crashes..
					TIMAEventCycleCount = TotalCycleCount;
					KeyBounceEventCycleCount = TotalCycleCount;
				}
				TIMAEventPending = (TIMAEventCycleCount != MAX_CYCLE_COUNT);
				KeyBounceEventPending = (KeyBounceEventCycleCount != MAX_CYCLE_COUNT);
			}
		}

		public static void saveState(DataOutputStream dostream)
		throws IOException
		{
			int saveversion = SL_SAVE_VERSION; //change when changing savestate format
			dostream.writeInt(SL_MAGIX);
			dostream.writeInt(saveversion);

			OutputStream compress = null; 
			int compressionmethod = 0; // no compression
#ifndef USE_JAVA_MOBILE
			compressionmethod = 1; // GZIP compression
#endif

			dostream.writeInt(compressionmethod);
			switch (compressionmethod) {
				// no compression
				case 0: break;
#ifndef USE_JAVA_MOBILE
				// GZIP compression
				case 1: {
					compress = new GZIPOutputStream(dostream);
					dostream = new DataOutputStream(compress);
				}; break;
				// LZ compression
				case 2: {
					compress = new LZOutputStream(dostream);
					dostream = new DataOutputStream(compress);
				}; break;
#endif
				default: ASSERT(false);
			}
			stateSaveLoad(true, saveversion, dostream, null);

			dostream.flush();			
			// if there was a compressor, close it so it finishes its output
			if (compress != null) compress.close();
		}

		public static void loadState(DataInputStream distream)
		throws IOException
		{
			int loadversion;
			int magix = distream.readInt();
			if (magix != SL_MAGIX) {
				// throw new IOException("save state not valid");
				// hax! 1 in 0xffffffff chance this goes wrong!
				loadversion = 0;
				B = (magix >> 24) & 0xff;
				C = (magix >> 16) & 0xff;
				D = (magix >>  8) & 0xff;
				E = (magix >>  0) & 0xff;
			} else
				loadversion = distream.readInt();
			if (loadversion < SL_LOAD_MIN_VERSION)
				throw new IOException("save state too old");
			if (loadversion > SL_LOAD_MAX_VERSION)
				throw new IOException("save state too new");
			if (loadversion != SL_SAVE_VERSION)
				PRINTLN("loading state with old version:"+loadversion);

			int compressionmethod = 0;
			if (loadversion >= SL_LOAD_COMPRESS_VERSION)
				compressionmethod = distream.readInt();
			switch (compressionmethod) {
				// no compression
				case 0: break;
#ifndef USE_JAVA_MOBILE
				// GZIP compression
				case 1: distream = new DataInputStream(new GZIPInputStream(distream)); break;
				// LZ compression
				case 2: distream = new DataInputStream(new LZInputStream(distream)); break;
#endif
				default: throw new IOException("unknown compression method:"+compressionmethod);
			}
			stateSaveLoad(false, loadversion, null, distream);
		}

		public static BTYPE[][] rMemMap = new BTYPE[0x10][];
		public static BTYPE[][] wMemMap = new BTYPE[0x10][];

		public static boolean isCGB() {
			//PRINTLN("** <INSERT DESCRIPTIVE TEXT HERE> ** [0x0143] = " + read(0x0143));
			if(cartridge==null) return false;
			return (read(0x0143) == 0x80) || (read(0x0143) == 0xC0);
		}

		public static int hblank_dma() {
			ASSERT((VC.STAT&2)==0);
			if (hblank_dma_state < (1<<7)) return 0;

			int src = ((IOP[0x51]<<8)|IOP[0x52]) & 0xfff0;
			int dst = (((IOP[0x53]<<8)|IOP[0x54]) & 0x1ff0) | 0x8000;
			int len = 16;

			for (int i = 0; i < len; ++i)
				VC.write(dst++, read(src++));

			IOP[0x51] = src >> 8;
			IOP[0x52] = src & 0xF0;
			IOP[0x53] = 0x1F & (dst >> 8);
			IOP[0x54] = dst & 0xF0;
			--IOP[0x55];
			--hblank_dma_state;

			return 8;
		}

		public static void refreshMemMap() {
			if (BIOS_enabled)
				rMemMap[0x0] = null;
			else
				rMemMap[0x0] = cartridge.MM_ROM[0];
			// cartridge ROM bank 0 (read only, write has special functions)
			rMemMap[0x1] = cartridge.MM_ROM[1];
			rMemMap[0x2] = cartridge.MM_ROM[2];
			rMemMap[0x3] = cartridge.MM_ROM[3];

#ifdef ENABLE_RECOMPILER
			rccachex = rccachea[cartridge.CurrentROMBank];
#endif

			// cartridge ROM switchable bank (read only, write has special functions)
			rMemMap[0x4] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|0];
			rMemMap[0x5] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|1];
			rMemMap[0x6] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|2];
			rMemMap[0x7] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|3];

			// 0x8 // TODO: somehow fit VRAM in here, difficult cause its
			// 0x9 //       not in 0xFFF chunks (and VC doesnt want it that way)

			// cartridge RAM (can be switchable)
			if(cartridge.MBC!=2) { //MBC2 should not have any RAM (except built in 512x4bits)
				rMemMap[0xA] = wMemMap[0xA] = cartridge.MM_RAM[(cartridge.CurrentRAMBank<<1)|0];
				rMemMap[0xB] = wMemMap[0xB] = cartridge.MM_RAM[(cartridge.CurrentRAMBank<<1)|1];
			}
			else { //force reading through Cartridge
				rMemMap[0xA] = wMemMap[0xA] = null;
				rMemMap[0xB] = wMemMap[0xB] = null;
			}

			// WRAM, bank 0 and a switchable bank
			rMemMap[0xC] = wMemMap[0xC] = WRAM[0];
			rMemMap[0xD] = wMemMap[0xD] = WRAM[CurrentWRAMBank];

			// echo..
			rMemMap[0xE] = wMemMap[0xE] = rMemMap[0xC];

			// 0xF // lots of special stuff here...

			setPC(getPC());
		}

		public static int read(int index) {
			#ifdef EXTRADEBUG
				last_memory_access_internal=index;
			#endif
			BTYPE mm[]=rMemMap[index>>12];
			if (mm!=null)
				return B2I(mm[index&0x0FFF]);
			return read_slow(index);
		}

		public static int read_slow(int index) {
			/* Memorymap:
			 * 0000-3FFF   16KB ROM Bank 00     (in cartridge, fixed at bank 00)
			 * 4000-7FFF   16KB ROM Bank 01..NN (in cartridge, switchable bank number)
			 * 8000-9FFF   8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
			 * A000-BFFF   8KB External RAM     (in cartridge, switchable bank, if any)
			 * C000-CFFF   4KB Work RAM Bank 0 (WRAM)
			 * D000-DFFF   4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
			 * E000-FDFF   Same as C000-DDFF (ECHO)    (typically not used)
			 * FE00-FE9F   Sprite Attribute Table (OAM)
			 * FEA0-FEFF   Not Usable
			 * FF00-FF7F   I/O Ports
			 * FF80-FFFE   High RAM (HRAM)
			 * FFFF        Interrupt Enable Register
			 */

			int b;
			#ifdef EXTRADEBUG
				last_memory_access_internal=index;
			#endif
			ASSERT(index>=0 && index <=0xffff);

			if (index < 0x4000) { //16KB ROM Bank 00     (in cartridge, fixed at bank 00)
				if (index < 0x100) {
			//PRINTLN("read_slow:"+index);
					b = cartridge.BIOS_ROM[index];
				    //PRINTLN("reading from BIOS rom");
				}
				else if (index == 0x100) {
// 					PRINTLN("reading from 0x100, disabling BIOS rom (PC="+PC+")");
					BIOS_enabled = false;
					//reset(false); // reset without forcing mono mode
					refreshMemMap();
					VC.isCGB = isCGB();
					A = VC.isCGB?0x11:0x01; // CGB sets this to 0x11 instead of 0x01 for GB
					b = read(index);
				}
				else {
					b = cartridge.MM_ROM[0][index];
					//PRINTLN("reading from non-BIOS rom");
				}
			}
			else if(index < 0x8000) { //16KB ROM Bank 01..NN (in cartridge, switchable bank number)
				b=cartridge.read(index);
			}
			else if(index < 0xa000) { //8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
				b=VC.read(index);
			}
			else if(index < 0xc000) { //8KB External RAM     (in cartridge, switchable bank, if any)
				b=cartridge.read(index);
			}
			else if(index < 0xd000) { //4KB Work RAM Bank 0 (WRAM)
				b=B2I(WRAM[0][index-0xc000]);
			}
			else if(index < 0xe000) { //4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
				b=B2I(WRAM[CurrentWRAMBank][index-0xd000]);
			}
			else if(index < 0xfe00) { //Same as C000-DDFF (ECHO)    (typically not used)
				b=read(index-0x2000);
			}
			else if(index < 0xfea0) { //Sprite Attribute Table (OAM)
				b=VC.read(index);
			}
			else if(index < 0xff00) { //Not Usable
				PRINTLN("WARNING: CPU.read(): Read from unusable memory (0xfea0-0xfeff)");
				b=0;
			}
			else if((index>0xff0f) && (index<0xff40)) { /* AUDIO IO PORTS: 0xff10 - 0xff3f */
				b = AC.read(index);
			}
			else if((index>0xff3f) && (index<0xff70)) { /* VIDEO IO PORTS: 0xff40 - 0xff6f */
				b = VC.read(index);
			}
			else if(index < 0xff80) { //I/O Ports
				switch(index) {
					case 0xff00: // FF00 - P1/JOYP - Joypad (R/W)
						b=(IOP[index-0xff00]&0x30)|0xc0;
						if((b&(1<<4))==0) { // Direction keys, 0=select
							b|=(KeyStatus&0x0f);
						}
						if((b&(1<<5))==0) { // Buttons, 0=select
							b|=(KeyStatus>>4);
						}
						b^=0x0f;
						break;
					case 0xff04: // DIV
						// could be simpler, but this way is it exactly the same as it was before
						return (int)((((TotalCycleCount + CYCLES_PER_DIV - 1 - divReset) / CYCLES_PER_DIV))&0xff);
					case 0xff01: // SB - Serial transfer data (R/W)
					case 0xff02: // SC - Serial Transfer Control (R/W)
						b = IOP[index-0xff00];
						break;
					case 0xff05: // TIMA
						if (cyclesPerTIMA != 0) {
							b =  (int)(((TotalCycleCount - TIMAEventCycleCount + (cyclesPerTIMA * 0x100)) / cyclesPerTIMA)&0xff);
						} else {
							b = IOP[0x05];
						}
						break;
					case 0xff06: // TMA
					case 0xff07: // TAC
						b = IOP[index-0xff00];
						break;
					case 0xff0f: // FF0F - IF - Interrupt Flag (R/W)
						b = IOP[0x0f];
						break;
					/* AUDIO IO PORTS: 0xff10 - 0xff3f */
					/* VIDEO IO PORTS: 0xff40 - 0xff6f */
					case 0xff70: // SVBK - CGB Mode Only - WRAM Bank
						b = CurrentWRAMBank;
						break;
					/** some 'undocumented' stuff... */
					case 0xff6c: // Undocumented (FEh) - bit 0 (Read/Write)
						PRINTF("WARNING: CPU.read(): Read from *undocumented* IO port $%04x\n",index);
						b = IOP[index-0xff00] | 0xfe;
						break;
					case 0xff72: // Undocumented (00h) - Bit 0-7 (Read/Write)
					case 0xff73: // Undocumented (00h) - Bit 0-7 (Read/Write)
					case 0xff74: // Undocumented (00h) - Bit 0-7 (Read/Write)
						b = IOP[index-0xff00];
						break;
					case 0xff75: // Undocumented (8Fh) - Bit 4-6 (Read/Write)
						PRINTF("WARNING: CPU.read(): Read from *undocumented* IO port $%04x\n",index);
						b = IOP[index-0xff00] | 0x8f;
						break;
					case 0xff76: // Undocumented (00h) - Always 00h (Read Only)
					case 0xff77: // Undocumented (00h) - Always 00h (Read Only)
						PRINTF("WARNING: CPU.read(): Read from *undocumented* IO port $%04x\n",index);
						b = 0;
						break;
					default:
						PRINTF("TODO: CPU.read(): Read from IO port $%04x\n",index);
						b=0xff; // GnuBoy compat
						break;
				}
			}
			else if(index < 0xffff) { //High RAM (HRAM)
				b = B2I(HRAM[index-0xff80]);
			}
			else if(index < 0x10000) { // Interrupt Enable Register (0xffff)
				b=IE;
			}
			else {
				PRINTLN("ERROR: CPU.read(): Out of range memory access: $"+index);
				b=0;
			}
			return b;
		}

		// has arguments swapped for recompiler use (stack order and stuff)
		public static void write_fast1(int value, int index) {

			#ifdef EXTRADEBUG
				last_memory_access_internal=index;
			#endif
			BTYPE mm[]=wMemMap[index>>12];
			if (mm!=null) {
				mm[index&0x0FFF] = I2B(value);
				return;
			}
			write_slow(index, value);
		}

		public static void write(int index, int value) {
			#ifdef EXTRADEBUG
				last_memory_access_internal=index;
			#endif
			BTYPE mm[]=wMemMap[index>>12];
			if (mm!=null) {
				mm[index&0x0FFF] = I2B(value);
				return;
			}
			write_slow(index, value);
		}

		public static void write_slow(int index, int value) {
			/* Memorymap:
			 * 0000-3FFF   16KB ROM Bank 00     (in cartridge, fixed at bank 00)
			 * 4000-7FFF   16KB ROM Bank 01..NN (in cartridge, switchable bank number)
			 * 8000-9FFF   8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
			 * A000-BFFF   8KB External RAM     (in cartridge, switchable bank, if any)
			 * C000-CFFF   4KB Work RAM Bank 0 (WRAM)
			 * D000-DFFF   4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
			 * E000-FDFF   Same as C000-DDFF (ECHO)    (typically not used)
			 * FE00-FE9F   Sprite Attribute Table (OAM)
			 * FEA0-FEFF   Not Usable
			 * FF00-FF7F   I/O Ports
			 * FF80-FFFE   High RAM (HRAM)
			 * FFFF        Interrupt Enable Register
			 */
			#ifdef EXTRADEBUG
				last_memory_access_internal=index;
			#endif
			ASSERT(wMemMap[index>>12] == null); // remove when not triggered for some time...

			ASSERT(index>=0 && index <=0xffff);

			if(index < 0x8000) { //cartridge ROM
				cartridge.write(index, value);

				refreshMemMap();
			}
			else if(index < 0xa000) { //8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
				VC.write(index, value);
			}
			else if(index < 0xc000) { //8KB External RAM     (in cartridge, switchable bank, if any)
				cartridge.write(index, value);
			}
			else if(index < 0xd000) { //4KB Work RAM Bank 0 (WRAM)
				WRAM[0][index-0xc000]=I2B(value);
			}
			else if(index < 0xe000) { //4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
				WRAM[CurrentWRAMBank][index-0xd000]=I2B(value);
			}
			else if(index < 0xfe00) { //Same as C000-DDFF (ECHO)    (typically not used)
				write(index-0x2000, value);
			}
			else if(index < 0xfea0) { //Sprite Attribute Table (OAM)
				VC.write(index, value);
			}
			else if(index < 0xff00) { //Not Usable
				/* Silenced since a lot of games seem to write to here anyway
				 * PRINTF("WARNING: CPU.write(): Write to unusable memory (0xfea0-0xfeff) index=$%04x, value=$%02x\n",index,value);
				 */
			}
			else if((index>0xff0f) && (index<0xff40)) { /* AUDIO IO PORTS: 0xff10 - 0xff3f */
				AC.write(index, value);
			}
			else if((index>0xff3f) && (index<0xff70)) { /* VIDEO IO PORTS: 0xff40 - 0xff6f */
				VC.write(index, value);
			}
			else if(index < 0xff80) { //I/O Ports
				switch(index) {
					case 0xff00: // FF00 - P1/JOYP - Joypad (R/W)
						IOP[index&0xff]=value;
						break;
					case 0xff01: // SB - Serial transfer data (R/W)
						IOP[0x01]=value;
						break;
					case 0xff02: // SC - Serial Transfer Control (R/W)
						IOP[0x02]=value;
						if(LinkCableStatus==0) { //Not connected to other emulator
							if ((value&(1<<7))!=0) {
								// transfer! (we do it instantly...)
								if ((value&(1<<0))!=0) {
									// internal clock, this 'works' without other GB
									IOP[0x01] = 0xFF; // 'works'
									IOP[0x02] &= ~(1<<7); // 'transfer' finished
									triggerInterrupt(3);
								}
								else {
									// external clock, nothing will happen
								}
							}
						}
						break;
					case 0xff04: // DIV
						// could be simpler, but this way is it exactly the same as it was before
						int tcycle = (int)(TotalCycleCount&0xff);
						if (tcycle == 0)
							divReset = TotalCycleCount;
						else
							divReset = TotalCycleCount-tcycle+CYCLES_PER_DIV;
						break;
					case 0xff05: // TIMA
						if (cyclesPerTIMA == 0) {
							IOP[0x05] = value; // is this correct? we did this previously too, but meboy only does when TIMA is active
						} else {
							// we don't reset the countdown here like meboy, but preserve the subtime position thin
							int prevval = read(0xff05);
							int prevcount = 0x100 - prevval;
							int newcount = 0x100 - value;
							TIMAEventCycleCount += cyclesPerTIMA * (newcount - prevcount);
							addEventCycleCount(TIMAEventCycleCount);
						}
						break;
					case 0xff06: // TMA
						IOP[0x06] = value;
						break;
					case 0xff07: // TAC
						if ((value&4) == 0 && cyclesPerTIMA != 0) {
							// disabling previously active TIMA, put correct value in register
							IOP[0x05] = read(0xff05); // would be slightly faster to inline the formula here...
						}
						IOP[0x07] = value;
						calcCyclesPerTIMA();
						calcTIMAEventCycleCount();
						break;
					case 0xff0f: // FF0F - IF - Interrupt Flag (R/W) (*Request* interrupts, and *shows* interrupts being queued)
						IOP[0x0f] = value;
						preCheckInts();
						break;
					/* AUDIO IO PORTS: 0xff10 - 0xff3f */
					/* VIDEO IO PORTS: 0xff40 - 0xff6f */
					case 0xff70: //FF70 - SVBK - CGB Mode Only - WRAM Bank
						CurrentWRAMBank=MAX(value&0x07, 1);
						refreshMemMap();
						break;
					/** some 'undocumented' stuff... */
					case 0xff72: // Undocumented (00h) - Bit 0-7 (Read/Write)
					case 0xff73: // Undocumented (00h) - Bit 0-7 (Read/Write)
					case 0xff74: // Undocumented (00h) - Bit 0-7 (Read/Write)
					case 0xff75: // Undocumented (8Fh) - Bit 4-6 (Read/Write)
						PRINTF("WARNING: CPU.write(): Write to *undocumented* IO port $%04x\n",index);
						IOP[index-0xff00] = value;
						break;
					case 0xff76: // Undocumented (00h) - Always 00h (Read Only)
					case 0xff77: // Undocumented (00h) - Always 00h (Read Only)
						PRINTF("WARNING: CPU.write(): Write to *undocumented* IO port $%04x\n",index);
						break;
					default:
						PRINTF("TODO: CPU.write(): Write %02x to IO port $%04x\n",value, index);
						break;
				}
			}
			else if(index < 0xffff) { //High RAM (HRAM)
				HRAM[index-0xff80] = I2B(value);
			}
			else if(index < 0x10000) { // FFFF - IE - Interrupt Enable (R/W)
				IE=value; // Interrupt Enable Register
				preCheckInts();
			}
			else {
				PRINTLN("ERROR: CPU.write(): Out of range memory access: $"+index);
			}
		}


		public static void reset() {
			reset(true);
		}

		public static void reset(boolean bios) {
			if(cartridge == null) return; //Do nothing if no cartridge is inserted
			BIOS_enabled = bios;

			VC.reset();
			cartridge.CurrentRAMBank=0;
			cartridge.CurrentROMBank=1;

			setPC(BIOS_enabled?0x00:0x100); // This should be set before refreshing the memmap, or risk setting BIOS_enabled to false
			refreshMemMap();

			VC.isCGB = BIOS_enabled?false:isCGB();

			//AF=$01B0
			A=BIOS_enabled ? 0x00 : (VC.isCGB?0x11:0x01); // CGB sets this to 0x11 instead of 0x01 for GB
			F=BIOS_enabled ? 0x00 : 0xb0;
			//BC=$0013
			B=0x00;
			C=BIOS_enabled ? 0x00 : 0x13;
			//DE=$00D8
			D=0x00;
			E=BIOS_enabled ? 0x00 : 0xd8;
			//HL=$014D
			H=BIOS_enabled ? 0x00 : 0x01;
			L=BIOS_enabled ? 0x00 : 0x4d;
			TotalInstrCount=0;
			TotalCycleCount=0;

			//Stack Pointer=$FFFE
			SP=BIOS_enabled ? 0x0000 : 0xfffe;

			//NOTE: I'm not sure what to init the audiocontroller to when the BIOS is active, so let's leave it like this
			write(0xff05, 0x00); // [$FF05] = $00   ; TIMA
			write(0xff06, 0x00); // [$FF06] = $00   ; TMA
			write(0xff07, 0x00); // [$FF07] = $00   ; TAC
			write(0xff26, 0xf1); // [$FF26] = $F1-GB, $F0-SGB ; NR52
			write(0xff47, 0xfc); // [$FF47] = $FC   ; BGP
			write(0xff48, 0xff); // [$FF48] = $FF   ; OBP0
			write(0xff49, 0xff); // [$FF49] = $FF   ; OBP1
			AC.reset(); // Sets FF11-FF25

			CurrentWRAMBank=1;
			doublespeed = false;
			speedswitch = false;
			divReset = 0;

			IE=0;         ///< Interrupt Enable (allowed interrupts)
			IME=true; ///< Interrupt Master Enable
			halted=false;
			KeyStatus=0; //bitmask
			keyBounce=0;
			lastKeyChange = 0;
			keyHistory.clear();
			hblank_dma_state = 0;
			playbackHistoryIndex = -1;
			keyHistoryEnabled = false;
			first_save_string = Version.str;
			delayed_halt = false;
			halt_fail_inc_pc = false;

			preCheckInts();

			NextEventCycleCount = 0;
			VCRenderEventCycleCount = 0;
			lastVCRenderCycleCount = 0;
			KeyBounceEventCycleCount = MAX_CYCLE_COUNT;
			KeyBounceEventPending = false;
			// TIMA Event variables are set by the writes to 0xff05-0xff07 above

			for (int i = 0; i < 0x80; ++i) IOP[i] = 0;
			for (int i = 0; i < 0x7f; ++i) HRAM[i] = 0;
			for (int i = 0; i < 0x08; ++i)
				for (int j = 0; j < 0x1000; ++j)
					WRAM[i][j] = 0;
		}

		public static long cycles() {
			return TotalInstrCount;
		}

		public static void printCPUstatus() {
			String flags = "";
			flags += (( F & ZF_Mask ) == ZF_Mask )?"Z ":"z ";
			flags += (( F & NF_Mask ) == NF_Mask )?"N ":"n ";
			flags += (( F & HC_Mask ) == HC_Mask )?"H ":"h ";
			flags += (( F & CF_Mask ) == CF_Mask )?"C ":"c ";
			flags += (( F & ( 1 <<3 ) ) == ( 1 <<3 ) )?"1 ":"0 ";
			flags += (( F & ( 1 <<2 ) ) == ( 1 <<2 ) )?"1 ":"0 ";
			flags += (( F & ( 1 <<1 ) ) == ( 1 <<1 ) )?"1 ":"0 ";
			flags += (( F & ( 1 <<0 ) ) == ( 1 <<0 ) )?"1 ":"0 ";
			PRINTLN( "---CPU Status for cycle "+TotalCycleCount+" , instruction "+TotalInstrCount+"---" );
			PRINTF( "   A=$%02x    B=$%02x    C=$%02x    D=$%02x   E=$%02x   F=$%02x   H=$%02x   L=$%02x\n", A, B, C, D, E, F, H,L );
			PRINTF( "  PC=$%04x SP=$%04x                           flags="+flags+"\n",getPC(),SP );
			#ifndef USE_JAVA_MOBILE
				PRINTLN( "  "+deasm.disassemble( getPC() ) );
			#endif
		}

		public static int checkInterrupts() { //handle interrupt priorities
			int ret = 0;
			if(IME) { // If interrupts enabled
				int ir = 0x1f&IOP[0x0f]&IE; //First Requested interrupts
				if((ir&(1<<0))!=0) {       //VBlANK
					IOP[0x0f] &= ~(1<<0);
					ir = 0x40;
				}
				else if ((ir&(1<<1))!=0) { //LCD STAT
					IOP[0x0f] &= ~(1<<1);
					ir = 0x48;
				}
				else if ((ir&(1<<2))!=0) { //Timer
					IOP[0x0f] &= ~(1<<2);
					ir = 0x50;
				}
				else if ((ir&(1<<3))!=0) { //Serial
					IOP[0x0f] &= ~(1<<3);
					ir = 0x58;
				}
				else if ((ir&(1<<4))!=0) { //Joypad
					IOP[0x0f] &= ~(1<<4);
					ir = 0x60;
				}
				if(ir > 0x1f) {
					IME = false;
					pushPC();
					setPC(ir);
					ret = 1;
				}
				preCheckInts();
			}
			return ret; // No interrupts to service
		}

		public static void triggerInterrupt(int i) { // request interrupt with bit nr #i
			IOP[0x0f] |= (1<<i);

			if (halted && IME && ((1<<i) & IE) != 0) halted = false;
			preCheckInts();
		}

		public static void pressButton(int i) {
			GUIKeyStatus |= i;
		}

		public static void releaseButton(int i) {
			GUIKeyStatus &= ~i;
		}

		public static void pressRemoteButton(int i) {
			RemoteKeyStatus |= i;
		}

		public static void releaseRemoteButton(int i) {
			RemoteKeyStatus &= ~i;
		}

		/** Performs a read of a register by internal register number */
		private static final int registerRead(int regNum) {
			switch (regNum) {
				case 0:
					return B;
				case 1:
					return C;
				case 2:
					return D;
				case 3:
					return E;
				case 4:
					return H;
				case 5:
					return L;
				case 6:
					return read(H<<8 | L);
				case 7:
					return A;
				default:
					return -1;
			}
		}

		public static void executeALU(int b1) {
			int operand = registerRead(b1 & 0x07);
			switch ((b1 & 0x38) >> 3) {
				case 1: // ADC A, r
					if ((F & CF_Mask) != 0) {
						operand++;
					}
					// Note!  No break!
				case 0: // ADD A, r

					if ((A & 0x0F) + (operand & 0x0F) >= 0x10) {
						F = HC_Mask;
					} else {
						F = 0;
					}

					A += operand;

					if (A > 0xff) {
						F |= CF_Mask;
						A &= 0xff;
					}

					if (A == 0) {
						F |= ZF_Mask;
					}
					break;
				case 3: // SBC A, r
					if ((F & CF_Mask) != 0) {
						operand++;
					}
					// Note! No break!
				case 2: // SUB A, r

					F = NF_Mask;

					if ((A & 0x0F) < (operand & 0x0F)) {
						F |= HC_Mask;
					}

					A -= operand;

					if (A < 0) {
						F |= CF_Mask;
						A &= 0xff;
					}
					if (A == 0) {
						F |= ZF_Mask;
					}

					break;
				case 4: // AND A, r
					A &= operand;
					if (A == 0) {
						F = HC_Mask + ZF_Mask;
					} else {
						F = HC_Mask;
					}
					break;
				case 5: // XOR A, r
					A ^= operand;
					F = (A == 0) ? ZF_Mask : 0;
					break;
				case 6: // OR A, r
					A |= operand;
					F = (A == 0) ? ZF_Mask : 0;
					break;
				case 7: // CP A, r (compare)
					F = NF_Mask;
					if (A == operand) {
						F |= ZF_Mask;
					} else if (A < operand) {
						F |= CF_Mask;
					}
					if ((A & 0x0F) < (operand & 0x0F)) {
						F |= HC_Mask;
					}
					break;
			}
		}

		public static void handleTIMAEvent()
		{
			IOP[0x05] = IOP[0x06];
			triggerInterrupt(2);
			TIMAEventCycleCount += cyclesPerTIMA * (0x100 - IOP[0x05]);
		};

		public static void handleKeyBounceEvent()
		{
			// Keybounce can't be implemented exactly cycle-perfect the same as previously
			// mostly because previously it was somewhat stupid:
			// -when cpu was halted, keybounce was delayed (so a keybounce interrupt could never resume the CPU from halted state)
			// -it was counted in instructions, to the actual cyclecount varied and is not predictable
			if (keyBounce > 0) {
				triggerInterrupt(4);
				--keyBounce;
				KeyBounceEventCycleCount = TotalCycleCount + (doublespeed ? 20000 : 10000); // gives more or less similar results as before
				KeyBounceEventPending = true;
			} else {
				KeyBounceEventCycleCount = MAX_CYCLE_COUNT;
				KeyBounceEventPending = false;
			}
		};

		public static void handleVCRenderEvent()
		{
			int cycles = (int)(TotalCycleCount - lastVCRenderCycleCount);

			if (doublespeed) cycles /= 2; // cycle counts are always even, so no need to account for rounding
			int cntdown = VC.render(cycles);
			if (doublespeed) cntdown *= 2;

			// NOTE: lastVCRenderCycleCount is used in VC.renderScanlinePart to determine how many pixels to render
			//       since the last render part. At the end of MODE3 this is called one last time so don't update
			//       lastVCRenderCycleCount until after the call to VC.render().
			lastVCRenderCycleCount = TotalCycleCount;
			VCRenderEventCycleCount = TotalCycleCount + cntdown;
			//VCRenderEventCycleCount = TotalCycleCount + 1;
		};

		public static void addEventCycleCount(long count)
		{
			if (count < NextEventCycleCount)
				NextEventCycleCount = count;
		};

		public static void handleEvents() {
			if (TotalCycleCount >= VCRenderEventCycleCount);
				handleVCRenderEvent();
			NextEventCycleCount = VCRenderEventCycleCount;

			if (TIMAEventPending) {
				if (TotalCycleCount >= TIMAEventCycleCount)
					handleTIMAEvent();
				addEventCycleCount(TIMAEventCycleCount);
			}

			if (KeyBounceEventPending) {
				if (TotalCycleCount >= KeyBounceEventCycleCount)
					handleKeyBounceEvent();
				addEventCycleCount(KeyBounceEventCycleCount);
			}
		};


		public static boolean fastCheckInts;
		public static void preCheckInts() {
			fastCheckInts = CHECK_INTS;
		}

		public static int execute() {
			int op;
			int cycles;
			TVARS;

			if (fastCheckInts) {
				checkInterrupts();
				halted = false;
				//return 4;// FIXME(?) For break on interrupt - note: 4 should be allright. RST takes 16 cycles
				return 5; //According to MESS "Taking an interrupt seems to take around 20 clock cycles."
			}

			if (delayed_halt && IME) {
				delayed_halt = false;
				halted = true;
			}

			if (halted) {
				// skip to next event
				return (int)((NextEventCycleCount - TotalCycleCount + 3)>>2);
			}

			if (halt_fail_inc_pc) {
				// failed to increment PC after halt
				halt_fail_inc_pc = false;
				--localPC;
			}

			if (localPC >= 0 && localPC < decoderMaxCruise) {
				op=B2I(decoderMemory[localPC++]);
			} else {
				int pc = getPC();
				op=read(pc++);
				setPC(pc);
			}

			cycles = Tables.cycles[op];

//#define break return cycles
			switch ( op ) {
				case 0x00: break;                                   // NOP
				case 0xf3: IME=false; preCheckInts(); break;        // DI
				case 0xfb: IME=true; preCheckInts(); break;         // IE
				case 0xea: WRITE_V(IMM16, A); break;                // LD   (nn), A
				case 0xfa: A = READ_V(IMM16); break;                // LD   A   , (nn)
				case 0xe0: WRITE_S(IMM8a | 0xff00, A); break;       // LDH  (n) , A
				case 0xf0: A = READ_S(IMM8a | 0xff00); break;       // LDH  A   , (n)
				case 0xe2: WRITE_S(C | 0xff00, A); break;           // LDH  (C) , A
				case 0xf2: A = READ_S(C | 0xff00); break;           // LDH  A   , (C)
				case 0xf9: SP = R16RHL; break;                      // LD   SP  , HL
				case 0x22: WRITE_V(R16RHL, A); DO_INC16(HL); break; // LDI  (HL), A
				case 0x2a: A = READ_V(R16RHL); DO_INC16(HL); break; // LDI  A   , (HL)
				case 0x32: WRITE_V(R16RHL, A); DO_DEC16(HL); break; // LDD  (HL), A
				case 0x3a: A = READ_V(R16RHL); DO_DEC16(HL); break; // LDD  A   , (HL)
				case 0xc3: DO_JP_NN; break;                         // JP   (nn)
				case 0xc2: DO_JP_COND((F&FZ)==0); break;            // JP   NZ  , (nn)
				case 0xca: DO_JP_COND((F&FZ)!=0); break;            // JP   Z   , (nn)
				case 0xd2: DO_JP_COND((F&FC)==0); break;            // JP   NC  , (nn)
				case 0xda: DO_JP_COND((F&FC)!=0); break;            // JP   C   , (nn)
				case 0xcd: DO_CALL_NN; break;                       // CALL (nn)
				case 0xc4: DO_CALL_COND((F&FZ)==0); break;          // CALL NZ  , (nn)
				case 0xcc: DO_CALL_COND((F&FZ)!=0); break;          // CALL Z   , (nn)
				case 0xd4: DO_CALL_COND((F&FC)==0); break;          // CALL NC  , (nn)
				case 0xdc: DO_CALL_COND((F&FC)!=0); break;          // CALL C   , (nn)
				case 0x18: DO_JR_D; break;                          // JR   (d)
				case 0x20: DO_JR_COND((F&FZ)==0); break;            // JR   NZ  , (d)
				case 0x28: DO_JR_COND((F&FZ)!=0); break;            // JR   Z   , (d)
				case 0x30: DO_JR_COND((F&FC)==0); break;            // JR   NC  , (d)
				case 0x38: DO_JR_COND((F&FC)!=0); break;            // JR   C   , (d)
				case 0xc9: DO_RET; break;                           // RET
				case 0xc0: DO_RET_COND((F&FZ)==0); break;           // RET  NZ
				case 0xc8: DO_RET_COND((F&FZ)!=0); break;           // RET  Z
				case 0xd0: DO_RET_COND((F&FC)==0); break;           // RET  NC
				case 0xd8: DO_RET_COND((F&FC)!=0); break;           // RET  C
				case 0x02: WRITE_V(R16RBC, A); break;               // LD   (BC), A
				case 0x0A: A = READ_V(R16RBC); break;               // LD   A   , (BC)
				case 0x12: WRITE_V(R16RDE, A); break;               // LD   (DE), A
				case 0x1A: A = READ_V(R16RDE); break;               // LD   A   , (DE)
				case 0x70: WRITE_V(R16RHL, B); break;               // LD   (HL), B
				case 0x71: WRITE_V(R16RHL, C); break;               // LD   (HL), C
				case 0x72: WRITE_V(R16RHL, D); break;               // LD   (HL), D
				case 0x73: WRITE_V(R16RHL, E); break;               // LD   (HL), E
				case 0x74: WRITE_V(R16RHL, H); break;               // LD   (HL), H
				case 0x75: WRITE_V(R16RHL, L); break;               // LD   (HL), L
				case 0x77: WRITE_V(R16RHL, A); break;               // LD   (HL), A
				case 0x36: WRITE_V(R16RHL, IMM8a); break;           // LD   (HL), n
				case 0x76: {                                        // HALT
					if (IME) {
						halted = true;
					} else {
						delayed_halt = true;
						if (!isCGB() && (IOP[0x0f]&IE) > 0)
							halt_fail_inc_pc = true;
					}
				}; break;
				case 0xd9: IME = true; preCheckInts(); DO_RET; break;               // RETI
				case 0xc1: R16WBC_V(POP); break;                    // POP  BC
				case 0xd1: R16WDE_V(POP); break;                    // POP  DE
				case 0xe1: R16WHL_V(POP); break;                    // POP  HL
				case 0xf1: R16WAF_V(POP); break;                    // POP  AF
				case 0xc5: DO_PUSH_V(R16RBC); break;                // PUSH BC
				case 0xd5: DO_PUSH_V(R16RDE); break;                // PUSH DE
				case 0xe5: DO_PUSH_V(R16RHL); break;                // PUSH HL
				case 0xf5: DO_PUSH_V(R16RAF); break;                // PUSH AF
				case 0x09: DO_ADD_HL(B, C); break;                  // ADD  HL  , BC
				case 0x19: DO_ADD_HL(D, E); break;                  // ADD  HL  , DE
				case 0x29: DO_ADD_HL(H, L); break;                  // ADD  HL  , HL
				case 0x39: DO_ADD_HL((SP>>8), (SP&0xff)); break;    // ADD  HL  , SP
				case 0xe9: setPC(R16RHL); break;                    // JP   HL
				case 0x2f: A ^= 0xff; F |= (FN|FH); break;          // CPL
				case 0x07: DO_SHOP_R(RLC, A); F &= FC; break;       // RLCA
				case 0x17: DO_SHOP_R(RL, A); F &= FC; break;        // RLA
				case 0x0f: DO_SHOP_R(RRC, A); F &= FC; break;       // RRCA
				case 0x1f: DO_SHOP_R(RR, A); F &= FC; break;        // RRA
				case 0xc7: pushPC(); setPC(0x00); break;            // RST  &0
				case 0xcf: pushPC(); setPC(0x08); break;            // RST  &8
				case 0xd7: pushPC(); setPC(0x10); break;            // RST  &10
				case 0xdf: pushPC(); setPC(0x18); break;            // RST  &18
				case 0xe7: pushPC(); setPC(0x20); break;            // RST  &20
				case 0xef: pushPC(); setPC(0x28); break;            // RST  &28
				case 0xf7: pushPC(); setPC(0x30); break;            // RST  &30
				case 0xff: pushPC(); setPC(0x38); break;            // RST  &38
				case 0x37: F &= FZ; F |= FC; break;                 // SCF
				case 0x3f: F &= (FZ|FC); F ^= FC; break;            // CCF
				case 0x08: {                                        // LD   (nn), SP
					t_acc = IMM16;
					WRITE_V(t_acc, SP&0xff);
					WRITE_F((t_acc+1)&0xffff , SP>>8);
				}; break;
				case 0xf8:{                                         // LD  HL, SP+dd
					R16WHL(SP);
					L += IMM8OFS;
					F = 0;
					if (L > 0xff) {
						L &= 0xff;
						F |= FH;
						++H;
						if (H > 0xff) {
							H &= 0xff;
							F |= FC;
						}
					}
					else if (L < 0) {
						L &= 0xff;
						F |= FH;
						--H;
						if (H < 0) {
							H &= 0xff;
							F |= FC;
						}
					}
				};break;
				case 0x27:{                                         // DAA
					t_acc = Tables.daa[(((F)&0x70)<<4) | A];
					A += t_acc;
					F = (F & (FN)) | ((A==0)?FZ:0) | Tables.daa_carry[t_acc>>2];
					A &= 0xff;
				};break;
				case 0xe8:{
					t_acc = SP;
					SP += IMM8OFS;
					F = ((SP >> 8) != (t_acc >> 8)) ? FH : 0;
					if ((SP & ~0xffff) != 0) {
						SP &= 0xffff;
						F |= CF_Mask;
					}
				};break;
				case 0x10: if (speedswitch) {                       // STOP
					PRINTLN("Speed switch!");
					doublespeed = !doublespeed;
					++localPC; // debuggin hax! gnuboy does this too! (fix?)
					speedswitch = false;
				}; break;
				CASES_ALU_OP(0xb8, 0xfe, CP)                        // CP   x            x = r, imm8, (HL)
				CASES_ALU_OP(0xa0, 0xe6, AND)                       // AND  x            x = r, imm8, (HL)
				CASES_ALU_OP(0xa8, 0xee, XOR)                       // XOR  x            x = r, imm8, (HL)
				CASES_ALU_OP(0xb0, 0xf6, OR)                        // OR   x            x = r, imm8, (HL)
				CASES_ALU_OP(0x80, 0xC6, ADD)
				CASES_ALU_OP(0x88, 0xCE, ADC)
				CASES_ALU_OP(0x90, 0xD6, SUB)
				CASES_ALU_OP(0x98, 0xDE, SBC)
				CASES_INCDEC8
				CASES_INCDEC16
				CASES_LD_XX
				case 0xcb: // prefix instruction
					op = IMM8a;
					cycles = Tables.cb_cycles[op];
					switch ( op ) {
						CASES_CB_BITNUM(0x40, BIT)
						CASES_CB_BITNUM(0x80, RES)
						CASES_CB_BITNUM(0xc0, SET)
						CASES_CB_SHOP(0x00, RLC)
						CASES_CB_SHOP(0x08, RRC)
						CASES_CB_SHOP(0x10, RL)
						CASES_CB_SHOP(0x18, RR)
						CASES_CB_SHOP(0x20, SLA)
						CASES_CB_SHOP(0x28, SRA)
						CASES_CB_SHOP(0x38, SRL)
						CASES_CB_SWAP
						default:
						PRINTF( "UNKNOWN PREFIX INSTRUCTION: $%02x (" + op + ")\n" , op );
						localPC -= 2;
						return 0;
					}
					break;
				default:
					/*if ((op & 0xC0) == 0x80) {
						executeALU(op);
						return cycles;
					} else */{
						PRINTF( "UNKNOWN INSTRUCTION: $%02x (" + op + ")\n" , op );
						localPC -= 1; // we failed to execute the instruction, so restore PC
						return 0;
					}
			}
//#undef break
			return cycles;
		}

		static long lastns = 0;
		static long lastuf = 0;
		static int samplesLeft = 0;

#ifdef ENABLE_RECOMPILER
		static class DummyCPURunBlock implements CPURunBlock {
			public int execute() { ASSERT(false); return 0;};
		}

		static CPURunBlock dummyrc = new DummyCPURunBlock();
		static CPURunBlock[][] rccachea =  new CPURunBlock[0xff][0x4000];
		static CPURunBlock[] rccache0 =  rccachea[0];
		static CPURunBlock[] rccachex =  new CPURunBlock[0x4000];
		static int[] rccnt =  new int[0x4000];
#endif

		/* Elapse time should be called whenever an event happens that consumes time.
		 * It will update all relevant timers. Input is the ammount of time that supposedly
		 * has elapsed, in 'real' cpu cycles.
		 */
		public static void elapseTime(int cycles) {
			TotalCycleCount += cycles;
		}

#ifdef EXTRADEBUG
	#define THROW(msg) { throw new RuntimeException(msg); }
#else
	#define THROW(msg) { throw new RuntimeException(); }
#endif

		// runloop aborts when this is set to false
		public static boolean keeprunning;

		public static void runlooprun() {
			int cycles;
			do {
				if (TotalCycleCount >= NextEventCycleCount)
					handleEvents();

				#ifdef USE_JAVA_MOBILE
					if (KeyStatus != GUIKeyStatus) {
							KeyStatus = GUIKeyStatus;
							keyBounce = 1000;
							handleKeyBounceEvent();
					}
				#else
					if (playbackHistoryIndex == -1) {
						if (KeyStatus != GUIKeyStatus) {
							keyBounce = 1000;
							handleKeyBounceEvent();
						}
						if (KeyStatus != GUIKeyStatus || lastKeyChange > 0x3fffffff) {
							KeyStatus = GUIKeyStatus;
							keyHistory.add(lastKeyChange);
							keyHistory.add(KeyStatus);
							lastKeyChange = 0;
						}
					} else if (playbackHistoryIndex < keyHistory.size()) {
						int d = keyHistory.get(playbackHistoryIndex);
						if (d <= lastKeyChange) {
							//PRINTLN("Playback!"+playbackHistoryIndex);
							lastKeyChange = 0;
							++playbackHistoryIndex;
							d = keyHistory.get(playbackHistoryIndex++);
							if (KeyStatus != d)  {
								KeyStatus = d;
								keyBounce = 1000;
								handleKeyBounceEvent();
							}
						}
					} else {
						playbackHistoryIndex = -1;
						keyHistoryEnabled = true;
					}
				#endif
				cycles = 4*execute();
				#ifndef USE_JAVA_MOBILE
					lastKeyChange += cycles;
				#endif
				#ifdef EXTRADEBUG
					++TotalInstrCount;
					last_memory_access=last_memory_access_internal;
				#endif

				/*** Elapse Time ***/
				TotalCycleCount += cycles;
				#ifndef USE_JAVA_MOBILE
					if (cycles > 0) {
						if (doublespeed) { // more instrs per vblank int
							AC.render(cycles>>1); //render enough sound bytes for cycles Cycles
						}
						else {
							AC.render(cycles); //render enough sound bytes for cycles Cycles
						}
					}
				#endif

				#ifndef USE_JAVA_MOBILE
					if (LinkCableStatus != 0) {
						LINKcntdwn -= cycles;
						if (LINKcntdwn < 0) {
							LINKcntdwn += (4096 / LINKmulti);
							// == 4194304/(1024*LINKmulti) (normal speed 8k bits/sec is 1k bytes/sec)
							//LINKcntdwn += 4096*9; // * 10 tetris hax to get more 'reasonable' speeds...
							try {
								int lstatus = IOP[0x02] | (IOP[0x01] << 8);
								int rstatus = -1;

								LINKbuf[LINKind++] = lstatus;

								lstatus |= RemoteKeyStatus << 16;

								LinkCableOut.writeInt(lstatus);
								LinkCableOut.flush();
								rstatus = LinkCableIn.readInt();

								if (useRemoteKeys) {
									int rkeys = (rstatus >> 16) & 0xff;
									if (GUIKeyStatus != rkeys) {
										GUIKeyStatus = rkeys;
									}
								}

								if (LINKind > LINKdelay) LINKind = 0;
								lstatus = LINKbuf[LINKind];

								int bstatus = (rstatus & 0xff) | ((lstatus & 0xff) << 8);
								bstatus &= 0x8181; // mask out ext/int clk and start transfer bits
																	// dont yet care about clockspeed...,
								switch (bstatus) {
									case 0x8080: case 0x8001: case 0x8000: {
										// waiting for external clock that isnt there...
										// PRINTLN("waiting for external clock that isnt there...");
									}; break;
									case 0x8101: case 0x8100: {
										// internal clock timeout
										// PRINTLN("internal clock timeout");
										if (++LINKtimeout > LINKdelay) {
											LINKtimeout = 0;
											IOP[0x01] = 0xff;
											IOP[0x02] &= ~0x80;
											triggerInterrupt(3);
										}
									}; break;
									case 0x8181: {
										// 2 internal clocks! conflict! panic! aargh!
										PRINTLN("Link: clock conflict");
									}; break;
									case 0x8180:   // local clock, swap bytes
									case 0x8081: { // remote clock, swap bytes
										//PRINTF("Link: swapping $%04x: $%02x <-> $%02x\n",bstatus,IOP[0x01] , rstatus >> 8);
										IOP[0x01] = (rstatus >> 8) & 0xff;
										IOP[0x02] &= ~0x80;
										triggerInterrupt(3);
										LINKtimeout = 0;
									}; break;
									default: {
										// no (local) transfer requested
										//PRINTF("Link: no swapping $%04x\n",bstatus);
									}
								}

							}
							catch (IOException e) {
								PRINTLN("Link exception");
								severLink();
							}

						}
					}
				#endif

			} while (keeprunning && cycles > 0);
			if (cycles == 0) THROW("nextinstruction() returned 0");
		};

		public static void runloop() {
			keeprunning = true;
			runlooprun();
		};

		public static void runlooponce() {
			keeprunning = false;
			runlooprun();
		};

		#include "linkcable.inc"
}
