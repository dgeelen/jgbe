#include "Global.inc"
#ifndef USE_JAVA_MOBILE
import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.dnd.*;
import java.awt.datatransfer.*;
import java.awt.event.*;
/* These may be needed for 'true' outline fonts
import java.awt.font.*;
import java.awt.geom.*;*/
import java.util.Scanner;
import java.net.*;
import java.io.*;
import java.util.ArrayList;
import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.zip.*;

#include "SaveLoad.inc"
#include "keyConfigDialog.inc"

class GlobalExceptionCatcher implements Thread.UncaughtExceptionHandler {
	GlobalExceptionCatcher() {}
	public void uncaughtException(Thread t, Throwable ee) { //Note: still dies on OutOfMemory error :-(
		final Throwable e=ee;
		if((swinggui.cpuRunner != null) && swinggui.cpuRunner.hasThread(t)) {
			/* The exception occured in the runner thread, but this is
			 * a required thread (because it is used by grfx.focusGained/focusLost)
			 * Any exception occuring in the Debugger is handled in the debugger,
			 * so we only need to handle the GUI runner here.
			 */
			swinggui.cpuRunner = null;
		} else
			swinggui.pauseEmulation(false);
		SwingUtilities.invokeLater( new Runnable() {
		public void run() {
		JFrame errMsg = new JFrame("Internal Error!");
		errMsg.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		JPanel iconAndText = new JPanel();
		JPanel iconAndTextAndTextField = new JPanel();
		BoxLayout bl;
		bl = new BoxLayout(iconAndText, BoxLayout.X_AXIS);
		iconAndText.setLayout(bl);
		iconAndTextAndTextField.setComponentOrientation(ComponentOrientation.LEFT_TO_RIGHT );
		bl = new BoxLayout(iconAndTextAndTextField, BoxLayout.PAGE_AXIS);
		iconAndTextAndTextField.setLayout(bl);
		iconAndText.add( new JLabel(UIManager.getIcon("OptionPane.errorIcon")) );
		JPanel spacer = new JPanel();
		iconAndText.add( spacer );
		iconAndText.add( new JLabel("<HTML><BODY>"+
		                            "There was an error within the emulator itself, this should not happen.<BR>"+
		                            "Please go to `http://code.google.com/p/jgbe/issues/' and submit a bug report with<BR>"+
		                            "the full text of the error message (as shown in the textfield below), and<BR>"+
		                            "(if possible) the steps neccesary to reproduce the error. Doing so will help<BR>"+
		                            "us fix this bug and improve JGBE.<BR>"+
		                            "</BODY></HTML>"
		                            ));
		JTextArea tf = new JTextArea();
		tf.setEditable(false);
		iconAndTextAndTextField.add(iconAndText);
		spacer = new JPanel();
		bl = new BoxLayout(spacer, BoxLayout.X_AXIS);
		spacer.setLayout(bl);
		spacer.add(new JLabel("Error message:"));
		spacer.add(new JPanel());
		iconAndTextAndTextField.add( spacer );
		tf.setBorder(BorderFactory.createLoweredBevelBorder());
		iconAndTextAndTextField.add(new JScrollPane(tf));
		String s = "Type of error: \"" + e.toString() + "\"\n" + "Stacktrace:\n";
		StackTraceElement[] ste = e.getStackTrace();
		for(int i=0; i<ste.length; ++i)
			s += ste[i] + "\n";
		tf.setText(s);
		errMsg.getContentPane().add( iconAndTextAndTextField );
		errMsg.pack();
		errMsg.setSize(new Dimension(640,480));
		Point     p = new Point();
		Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
		p.setLocation((d.getWidth()/2) - (errMsg.getWidth()/2), (d.getHeight()/2)-(errMsg.getHeight()/2));
		errMsg.setLocation(p);
		errMsg.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);
		errMsg.addWindowListener(new WindowAdapter() {
		                         	public void windowClosing(WindowEvent we) {
		                         		System.exit(-1);
		                         	}
		                         });
		errMsg.setVisible( true );
		}});
	}
}

class MenuItemArray extends VECTOR(JMenuItem) {
	public boolean add(JMenuItem b) {
		return super.add(b);
	}
	public void add(JMenuItem b, int mnemonic) {
		super.add(b);
		b.setMnemonic(mnemonic);
	}
	public void remove(JMenuItem b) {
		super.remove(b);
	}
	public void addActionListener(ActionListener l) {
		FOREACH(JMenuItem, ab, this)
			ab.addActionListener(l);
	}
	public void addToMenu(JMenu m) {
		FOREACH(JMenuItem, ab, this)
			m.add(ab);
	}
	public void addToMenu(JPopupMenu m) {
		FOREACH(JMenuItem, ab, this)
			m.add(ab);
	}
	public boolean contains(Object b) {
		return (b instanceof JMenuItem) && super.contains(b);
	}
	public JMenuItem getItem(int index) {
		return (JMenuItem)super.get(index);
	}
}

class MenuItemArrayGroup extends MenuItemArray {
	private ButtonGroup grp = new ButtonGroup();
	public boolean add(JMenuItem b) {
		boolean bbb = super.add(b);
		grp.add(b);
		return bbb;
	}
	public void add(JMenuItem b, int mnemonic) {
		super.add(b);
		grp.add(b);
	}
	public void remove(JMenuItem b) {
		super.remove(b);
		grp.remove(b);
	}
	public int getSelectedIndex() {
		int i = -1;
		FOREACH(JMenuItem, ab, this) {
			++i;
			if (ab.isSelected())
				return i;
		}
		return -1;
	}
	public void setSelectedIndex(int index) {
		int i = -1;
		FOREACH(JMenuItem, ab, this) {
			++i;
			ab.setSelected(i == index);
		}
	}
}

class SimpleCPURunner implements CPURunner, Runnable {
	private volatile int threadStatus = 0;
	private Thread cpurunthread;
	// 0 means suspended
	// 1 means suspend->running requested
	// 2 means running
	// 3 means running->suspended requested
	public boolean hasThread(Thread t) {
		return cpurunthread.equals(t);
	}

	synchronized public void suspend() {
		while (threadStatus != 0) {
			CPU.keeprunning = false;
			threadStatus = 3;
			while (threadStatus == 3) { YIELD; };
		}
	}

	synchronized public void resume() {
		if (!CPU.canRun()) return;
		if (threadStatus != 2) {
			threadStatus = 1;
			while (threadStatus == 1) { YIELD; };
		}
	}

	public boolean isRunning() {
		return (threadStatus != 0);
	}

	SimpleCPURunner() {
		cpurunthread = new Thread(this);
		cpurunthread.start();
		while (!cpurunthread.isAlive()) { YIELD; }; // wait for thread to actually start
	}

	public void run() {
		while (true) {
			// suspended
			while (threadStatus == 0) { YIELD; };

			// suspend -> running
			if (threadStatus == 1) threadStatus = 2;

			// running
			CPU.runloop();

			if (threadStatus == 2) { // CPU returned exception
				threadStatus = 3;
				SwingUtilities.invokeLater( new Runnable() {
				                            public void run() {
				                            	JOptionPane.showMessageDialog(null,
				                            	"Encountered an invalid instruction, perhaps ROM is broken?",
				                            	"Invalid Instruction",
				                            	JOptionPane.INFORMATION_MESSAGE);
				                            }});
			}

			// running -> suspended
			if (threadStatus == 3) threadStatus = 0;
			// suspended
		}
	}
}

public final class swinggui extends JApplet implements ActionListener, ItemListener, KeyListener, ComponentListener, WindowListener, MouseMotionListener, FocusListener {
		private IntVector saveStateOrder = new IntVector();
		private static DrawingArea grfx;
		private int lastmousex;
		private int lastmousey;
		private int lastmousecnt;
		private int mousehidden = 0;
		protected VideoController VC;
		protected CPU cpu;
		protected AudioDriver audioDriver;
		private int fps;
		private boolean isApplet;
		private int selectedState = 0;
		private int[] keyMap = new int[16+nrOfShortCuts]; // first 8: player 1, next 8: player 2, etc, last N-4*8 = shortcuts
		static VECTOR(String) osdLines = new VECTOR(String)();
		VECTOR(String) rcFiles = new VECTOR(String)();
		static int osdTimer = 1;
		private static int titleUpdateCountDown = 0;
		static public String curcartname;
		static public String biosfilename;
		static public DataOutputStream speedRunPlayWithOutputVideoStream;
		//menuitem <-- here for my KDev autocomplete
		JMenuItem menuitemExit;
		MenuItemArrayGroup scaleRadioGroup;
		MenuItemArrayGroup interpolationRadioGroup;
		JCheckBoxMenuItem keepAspectRatio;
		JCheckBoxMenuItem enableFullScreen;
		JMenuItem menuitemOpenROM;
		JMenuItem menuitemSaveState;
		JMenuItem menuitemLoadState;
		JMenuItem menuitemSaveOldestState;
		JMenuItem menuitemIncFrameSkip;
		JMenuItem menuitemDecFrameSkip;
		JCheckBoxMenuItem menuitemEnableSound;
		MenuItemArrayGroup savestateRadioGroup;
		JMenuItem[] menuItems; //Savestates?
		JMenuItem menuitemSeparator;
		JMenuItem menuitemPause;
		JMenuItem menuitemReset;
		JMenu menuColorScheme;
		JCheckBoxMenuItem[] menuitemColorSchemes;
		JCheckBoxMenuItem menuitemMixFrame;
		JCheckBoxMenuItem menuitemIgnoreSTAT;

		JMenu menuSoundChannels;
		MenuItemArray soundChannelGroup;
		JMenu menuOther;
		JMenuItem menuitemCheats;
		JCheckBoxMenuItem menuitemEnableCheats;
		JCheckBoxMenuItem menuitemUseBIOS;
		JMenuItem menuitemSetBIOS;
		JMenu menuEmuSpeed;
		JMenuItem menuitemEmuSpeedPlus;
		JMenuItem menuitemEmuSpeedMinus;
		JMenuItem menuitemEmuSpeedMul;
		JMenuItem menuitemEmuSpeedDiv;
		JMenuItem menuitemEmuSpeedNormal;
		JMenu menuLink;
		JMenuItem menuitemLinkServe;
		JMenuItem menuitemLinkClient;
		JMenuItem menuitemLinkSever;
		JMenuItem menuitemConfigKeys;
		JCheckBoxMenuItem	menuitemToggleRemoteKeys;
		JCheckBoxMenuItem menuitemSpeedRunRecord; //Resets CPU and enables Recording
		JCheckBoxMenuItem menuitemSpeedRunPlay;   //Resets CPU and enables Playback
		JCheckBoxMenuItem menuitemSpeedRunPlayWithOutput; //Play to file/pipe for encoding
		JMenuItem menuitemShowAdvancedAudioPropertiesDialog;

		static CheatCodeEditor cheatcodes;
		static AdvancedAudioPropertiesDialog advancedAudioPropertiesDialog;
		static CPURunner cpuRunner;

		protected ColorSelector cs;

		public void updateCartName(String fname) {
			int slashPos = fname.lastIndexOf(File.separator);
			int dotPos = fname.lastIndexOf(".");
			if (dotPos == -1) dotPos = fname.length();
			curcartname = fname.substring(slashPos+1, dotPos);
// 			PRINTLN("cartname = " + curcartname);

			rcFiles.remove(fname);
			rcFiles.add(0, fname);
			while(rcFiles.size()>10) //FIXME: Hardcoded :0
				rcFiles.remove(rcFiles.size()-1);
			saveRCFiles();
		}

		public class DrawingArea extends JPanel implements IVideoListener {
			private static final long serialVersionUID = 1L; // prevent warning

			public int interpolation;
			VideoController VC;
			public DrawingArea(VideoController vc) {
				super();
				VC=vc;
			}
			Color ColorTextShadow = new Color(128,128,128);
			Color ColorTextLight  = new Color(255,255,255);
			int DrawingAreaFontSize = 10;
			Font DrawingAreaFont = new Font("SansSerif", Font.BOLD, DrawingAreaFontSize);

			public void newVideoImage() {
				updateVideoImage(cpu.VC.getImage());
			}

			public void updateVideoImage(Image img) {
				repaint();
				if( speedRunPlayWithOutputVideoStream != null) {
					BufferedImage bimg = (BufferedImage)img;
					int[] data = (int[])bimg.getRaster().getDataElements(0,0,bimg.getWidth(),bimg.getHeight(),null);
					//PRINTF("Width = %d, Height= %d, Length = %d\n",bimg.getWidth(),bimg.getHeight(),data.length);
					for(int i=0; i<data.length; ++i) {
						int j = data[i];
						int ar = (j>>16)&0xff;
						int ag = (j>> 8)&0xff;
						int ab = (j>> 0)&0xff;
						try {
							speedRunPlayWithOutputVideoStream.writeByte(ar);
							speedRunPlayWithOutputVideoStream.writeByte(ag);
							speedRunPlayWithOutputVideoStream.writeByte(ab);
						}
						catch (IOException ee) {
							speedRunPlayWithOutputVideoStream = null;
							JOptionPane.showMessageDialog(frame,
							                              "Error while writing to file, aborting recording:\n"+ee.getMessage(),
							                              "Error!",
							                               JOptionPane.ERROR_MESSAGE);
						}
					}
				}
			}

			Image menuimage = null;
			Image scaledLogo = null;
			public void paintComponent(Graphics g) {
				super.paintComponent(g);

				if((logo != null)) {
					if((scaledLogo==null) || ((scaledLogo!=null) && !((scaledLogo.getHeight(null) == getHeight()) || (scaledLogo.getWidth(null) == getWidth())))) {
						double imgaspect = (((double)logo.getWidth(null))/((double)logo.getHeight(null))); // Image aspect
						double wndaspect = (((double)getWidth()) / ((double)getHeight()));                         // Display aspect
						if( imgaspect > wndaspect ) { // Image wider than window
							scaledLogo = logo.getScaledInstance(getWidth(), (int)(getWidth()/imgaspect), Image.SCALE_AREA_AVERAGING);
						} else
						if( imgaspect < wndaspect  ) { // Image narrower than window
							scaledLogo = logo.getScaledInstance((int)(getHeight()*imgaspect), getHeight(), Image.SCALE_AREA_AVERAGING);
						} else
							scaledLogo = logo.getScaledInstance(getWidth(), getHeight(), Image.SCALE_AREA_AVERAGING);
					}
					if(scaledLogo != null) {
						while((scaledLogo.getWidth(null)==-1) || (scaledLogo.getHeight(null)==-1)) YIELD;
						Dimension size = new Dimension(scaledLogo.getWidth(null), scaledLogo.getHeight(null));
						int x = (getWidth() - size.width)/2;
						int y = (getHeight() - size.height)/2;
						g.drawImage(scaledLogo, x, y, this);
						return;
					}
				} else scaledLogo = null;

				if (interpolation == 0) {
					g.drawImage(cpu.VC.getImage(),0,0, this);
				} else {
					((Graphics2D)g).setRenderingHint(RenderingHints.KEY_INTERPOLATION,
						(interpolation == 1) ? RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR  :
						(interpolation == 2) ? RenderingHints.VALUE_INTERPOLATION_BILINEAR  :
						(interpolation == 3) ? RenderingHints.VALUE_INTERPOLATION_BICUBIC  :
						null
					);

					g.drawImage(cpu.VC.getImage(),0,0, getWidth(),getHeight(), this);
				}
				if (osdLines.size() > 0) {
					while (osdLines.size() > 3*VC.nscale) //Made this 3 by user request
						osdLines.remove(0);
					g.setColor(new Color(255,255,255));
					for (int i = 0; i < osdLines.size(); ++i) {
						//FIXME: Make proper Font Outlines (Difficulty: Very Hard)
						String s=(String)osdLines.get(i);
// 						g.drawString(s, 9,  10+10*i);
// 						g.drawString(s, 10,  9+10*i);
// 						g.setFont(DrawingAreaFont);
						g.setColor(ColorTextShadow);
						g.drawString(s, 11, (DrawingAreaFontSize+1)+DrawingAreaFontSize*i);
						g.drawString(s, 11, (DrawingAreaFontSize+1)+DrawingAreaFontSize*i);
						g.setColor(ColorTextLight);
						g.drawString(s, 10, DrawingAreaFontSize+DrawingAreaFontSize*i);
					}
				}
				++fps;
				if (fulls) {
					int mheight = mainMenuBar.getHeight();
					if (lastmousey <= mheight) {
						int mwidth = mainMenuBar.getWidth();
						Rectangle bounds = getBounds();
						if (mwidth > bounds.x && mheight > bounds.y) {
							// menubar overlaps screen panel, need to redraw some parts of the menu on top of the screen
							if (menuimage == null)
								menuimage = new BufferedImage(mainMenuBar.getWidth(), mainMenuBar.getHeight(), BufferedImage.TYPE_INT_RGB);
							mainMenuBar.paint(menuimage.getGraphics());
							g.drawImage(menuimage,
								0, 0,
								mwidth - bounds.x, mheight - bounds.y,
								bounds.x, bounds.y,
								mwidth, mheight,
								this);
						}
					} else if (--lastmousecnt == 0) {
						try {
							addOSDLine("Hiding mouse");
							new Robot().mouseMove(fsframe.getWidth(), fsframe.getHeight());
							mousehidden = 1;
						} catch (AWTException e) {
						}
					}
				}
			}
		}

		public static void addOSDLine(String line) {
			osdLines.add(line);
			osdTimer=4*2;
		}

		public swinggui() {
			isApplet = false;
		}

		private JMenu menuFile;

		private JMenuBar mainMenuBar;

		private JMenuBar createJMenuBar() {
			JMenuBar mainMenuBar;
			JMenu menuVideo;
			JMenu menuScaling;
			JMenu menuFrameSkip;
			JMenu menuState;
			JMenu menuSound;
			JMenu menuColor;
			mainMenuBar = new JMenuBar();

			menuFile = new JMenu( "File" );
			menuFile.setMnemonic( KeyEvent.VK_F );
			mainMenuBar.add( menuFile );
			menuVideo = new JMenu( "Video" );
			menuVideo.setMnemonic( KeyEvent.VK_V );
			mainMenuBar.add( menuVideo );

			menuitemOpenROM = new JMenuItem("Open ROM", KeyEvent.VK_O);
			menuitemOpenROM.addActionListener( this );
			menuFile.add(menuitemOpenROM);
			menuitemPause=new JMenuItem("Pause", KeyEvent.VK_P);
			menuitemPause.addActionListener(this);
			menuFile.add(menuitemPause);
			menuitemReset=new JMenuItem("Reset", KeyEvent.VK_R);
			menuitemReset.addActionListener(this);
			menuFile.add(menuitemReset);

			menuitemExit = new JMenuItem( "Exit", KeyEvent.VK_X );
			menuitemExit.addActionListener( this );
			menuFile.add( menuitemExit );

			enableFullScreen = new JCheckBoxMenuItem("Full Screen");
			enableFullScreen.setMnemonic(KeyEvent.VK_F);
			enableFullScreen.addActionListener(this);
			menuVideo.add(enableFullScreen);

			menuitemMixFrame = new JCheckBoxMenuItem("Mix Frame");
			menuitemMixFrame.setMnemonic(KeyEvent.VK_M);
			menuitemMixFrame.addActionListener( this );
			menuVideo.add(menuitemMixFrame);

			menuVideo.addSeparator();

			menuScaling = new JMenu( "Scaling");
			scaleRadioGroup = new MenuItemArrayGroup();
			scaleRadioGroup.add(new JRadioButtonMenuItem( "Scale 1x" ), KeyEvent.VK_1);
			scaleRadioGroup.add(new JRadioButtonMenuItem( "Scale 2x" ), KeyEvent.VK_2);
			scaleRadioGroup.add(new JRadioButtonMenuItem( "Scale 3x" ), KeyEvent.VK_3);
			scaleRadioGroup.add(new JRadioButtonMenuItem( "Scale 4x" ), KeyEvent.VK_4);
			scaleRadioGroup.addActionListener( this );
			scaleRadioGroup.addToMenu(menuScaling);
			menuScaling.addSeparator();

			interpolationRadioGroup = new MenuItemArrayGroup();
			interpolationRadioGroup.add(new JRadioButtonMenuItem("No Interpolation (fixed window size)"));
			interpolationRadioGroup.add(new JRadioButtonMenuItem("Nearest Neighbour Interpolation"));
			interpolationRadioGroup.add(new JRadioButtonMenuItem("BiLinear Interpolation"));
			interpolationRadioGroup.add(new JRadioButtonMenuItem("BiCubic Interpolation"));

			interpolationRadioGroup.addActionListener(this);
			interpolationRadioGroup.addToMenu(menuScaling);

			menuScaling.addSeparator();
			keepAspectRatio = new JCheckBoxMenuItem("Keep ascpect ratio");
			keepAspectRatio.addActionListener(this);
			menuScaling.add(keepAspectRatio);

			menuVideo.add( menuScaling) ;

			menuFrameSkip = new JMenu( "Frame Skipping");
			menuitemIncFrameSkip = new JMenuItem( "Increase Frame Skip", KeyEvent.VK_I );
			menuitemDecFrameSkip = new JMenuItem( "Decrease Frame Skip", KeyEvent.VK_D );
			menuitemIncFrameSkip.addActionListener( this );
			menuitemDecFrameSkip.addActionListener( this );
			menuFrameSkip.add( menuitemIncFrameSkip );
			menuFrameSkip.add( menuitemDecFrameSkip );
			menuVideo.add( menuFrameSkip) ;

			menuColorScheme = new JMenu("Color scheme");
			menuitemColorSchemes = new JCheckBoxMenuItem[5];
			menuitemColorSchemes[0] = new JCheckBoxMenuItem("GameBoy LCD", false);
			menuitemColorSchemes[0].setMnemonic(KeyEvent.VK_L);
			menuitemColorSchemes[1] = new JCheckBoxMenuItem("GameBoy Pocket/Light", false);
			menuitemColorSchemes[1].setMnemonic(KeyEvent.VK_P);
			menuitemColorSchemes[2] = new JCheckBoxMenuItem("Black and White", false);
			menuitemColorSchemes[2].setMnemonic(KeyEvent.VK_B);
			menuitemColorSchemes[3] = new JCheckBoxMenuItem("Graytones", false);
			menuitemColorSchemes[3].setMnemonic(KeyEvent.VK_G);
			menuitemColorSchemes[4] = new JCheckBoxMenuItem("Custom", false);
			menuitemColorSchemes[4].setMnemonic(KeyEvent.VK_C);
			for (int i = 0; i < menuitemColorSchemes.length; ++i) {
				menuColorScheme.add(menuitemColorSchemes[i]);
				menuitemColorSchemes[i].addActionListener(this);
			}
			menuVideo.add(menuColorScheme);

			menuState = new JMenu("State");
			menuState.setMnemonic(KeyEvent.VK_S);
			menuitemSaveState = new JMenuItem( "Save State", KeyEvent.VK_S );
			menuitemLoadState = new JMenuItem( "Load State", KeyEvent.VK_L );
			menuitemSaveOldestState = new JMenuItem( "Save To Oldest State", KeyEvent.VK_O );

			menuitemSaveState.addActionListener( this );
			menuitemLoadState.addActionListener( this );
			menuitemSaveOldestState.addActionListener( this );

			menuState.add( menuitemSaveState );
			menuState.add( menuitemLoadState );
			menuState.add( menuitemSaveOldestState );
			menuState.addSeparator();
			savestateRadioGroup = new MenuItemArrayGroup();
			for (int i = 0; i < 10; ++i) {
				savestateRadioGroup.add(new JRadioButtonMenuItem("Select State " + i), KeyEvent.VK_0 + i);
				savestateRadioGroup.getItem(i).setAccelerator( KeyStroke.getKeyStroke( KeyEvent.VK_0 + i, 0));
			}
			savestateRadioGroup.addActionListener(this);
			savestateRadioGroup.addToMenu(menuState);
			savestateRadioGroup.setSelectedIndex(0);

			mainMenuBar.add( menuState) ;

			menuSound = new JMenu( "Sound");
			menuSound.setMnemonic( KeyEvent.VK_U );
			menuitemEnableSound = new JCheckBoxMenuItem( "Enable sound", true );
			menuitemEnableSound.setMnemonic( KeyEvent.VK_T );
			menuitemEnableSound.addActionListener( this );
			menuSound.add( menuitemEnableSound );

			menuSoundChannels = new JMenu("Channels");
			soundChannelGroup = new MenuItemArray();
			soundChannelGroup.add(new JCheckBoxMenuItem("Enable channel 1"), KeyEvent.VK_1);
			soundChannelGroup.add(new JCheckBoxMenuItem("Enable channel 2"), KeyEvent.VK_2);
			soundChannelGroup.add(new JCheckBoxMenuItem("Enable channel 3"), KeyEvent.VK_3);
			soundChannelGroup.add(new JCheckBoxMenuItem("Enable channel 4"), KeyEvent.VK_4);
			soundChannelGroup.addActionListener(this);
			soundChannelGroup.addToMenu(menuSoundChannels);

			menuSound.add(menuSoundChannels);
			menuitemShowAdvancedAudioPropertiesDialog = new JMenuItem("Advanced...", KeyEvent.VK_A);
			menuitemShowAdvancedAudioPropertiesDialog.addActionListener(this);
			menuSound.add(menuitemShowAdvancedAudioPropertiesDialog);
			mainMenuBar.add( menuSound) ;
			menuOther=new JMenu("Other");
			menuOther.setMnemonic( KeyEvent.VK_O );
			menuitemCheats = new JMenuItem("Edit cheats", KeyEvent.VK_C);
			menuitemCheats.addActionListener(this);
			menuitemEnableCheats=new JCheckBoxMenuItem("Enable cheat codes", false);
			menuitemEnableCheats.setMnemonic(KeyEvent.VK_T);
			menuitemEnableCheats.addActionListener(this);
			menuitemUseBIOS=new JCheckBoxMenuItem("Run BIOS on reset", false);
			menuitemUseBIOS.setMnemonic(KeyEvent.VK_B);
			menuitemUseBIOS.addActionListener(this);
			menuitemSetBIOS=new JMenuItem("Select BIOS ROM", KeyEvent.VK_B);
			menuitemSetBIOS.addActionListener(this);

#ifdef SCALEBUILDER
			menuitemScaleBuilder=new JMenuItem("Built Scale", KeyEvent.VK_S);
			menuitemScaleBuilder.addActionListener(this);
			menuOther.add(menuitemScaleBuilder);
#endif
			menuitemToggleRemoteKeys = new JCheckBoxMenuItem("Use Remote Keys", false);
			menuitemToggleRemoteKeys.setMnemonic(KeyEvent.VK_R);
			menuitemToggleRemoteKeys.addActionListener(this);

			menuLink=new JMenu("Link");
			menuLink.setMnemonic( KeyEvent.VK_L );
			menuitemLinkServe = new JMenuItem("Start Link Server", KeyEvent.VK_S);
			menuitemLinkClient = new JMenuItem("Start Link Client", KeyEvent.VK_C);
			menuitemLinkSever = new JMenuItem("Stop Link", KeyEvent.VK_L);
			menuitemLinkServe.addActionListener(this);
			menuitemLinkClient.addActionListener(this);
			menuitemLinkSever.addActionListener(this);
			menuLink.add(menuitemLinkServe);
			menuLink.add(menuitemLinkClient);
			menuLink.add(menuitemLinkSever);
			mainMenuBar.add( menuLink ) ;

			menuitemConfigKeys = new JMenuItem("Config keys",KeyEvent.VK_1);
			menuitemConfigKeys.addActionListener(this);

			menuitemSpeedRunRecord = new JCheckBoxMenuItem("Record speedrun", false);
			menuitemSpeedRunPlay = new JCheckBoxMenuItem("Play speedrun", false);
			menuitemSpeedRunPlayWithOutput = new JCheckBoxMenuItem("Record speedrun to file", false);
			menuitemSpeedRunRecord.setMnemonic(KeyEvent.VK_E);
			menuitemSpeedRunPlay.setMnemonic(KeyEvent.VK_P);
			menuitemSpeedRunPlayWithOutput.setMnemonic(KeyEvent.VK_F);
			menuitemSpeedRunRecord.addActionListener(this);
			menuitemSpeedRunPlay.addActionListener(this);
			menuitemSpeedRunPlayWithOutput.addActionListener(this);

			menuOther.add(menuitemEnableCheats);
			menuOther.add(menuitemUseBIOS);
			menuOther.add(menuitemToggleRemoteKeys);
			menuOther.add(menuitemCheats);
			menuOther.add(menuitemSetBIOS);
			menuOther.add(menuitemConfigKeys);

			menuEmuSpeed = new JMenu("Emulation Speed");
			menuitemEmuSpeedPlus  = new JMenuItem("+25%", KeyEvent.VK_PLUS);
			menuitemEmuSpeedMinus = new JMenuItem("-25%", KeyEvent.VK_MINUS);
			menuitemEmuSpeedMul  = new JMenuItem("*125%", KeyEvent.VK_OPEN_BRACKET);
 			menuitemEmuSpeedDiv = new JMenuItem("*75%", KeyEvent.VK_CLOSE_BRACKET);
			menuitemEmuSpeedNormal= new JMenuItem("100%", KeyEvent.VK_EQUALS);
			menuitemEmuSpeedPlus.addActionListener(this);
			menuitemEmuSpeedMinus.addActionListener(this);
			menuitemEmuSpeedMul.addActionListener(this);
			menuitemEmuSpeedDiv.addActionListener(this);
			menuitemEmuSpeedNormal.addActionListener(this);

			menuEmuSpeed.add(menuitemEmuSpeedPlus);
			menuEmuSpeed.add(menuitemEmuSpeedMinus);
			menuEmuSpeed.add(menuitemEmuSpeedMul);
			menuEmuSpeed.add(menuitemEmuSpeedDiv);
			menuEmuSpeed.add(menuitemEmuSpeedNormal);
			menuOther.add(menuEmuSpeed ) ;
			menuOther.addSeparator();
			menuOther.add(menuitemSpeedRunRecord);
			menuOther.add(menuitemSpeedRunPlay);
			menuOther.add(menuitemSpeedRunPlayWithOutput);

			menuitemIgnoreSTAT = new JCheckBoxMenuItem("Ignore mode2/3 writelock", false);
			menuitemIgnoreSTAT.setMnemonic(KeyEvent.VK_I);
			menuitemIgnoreSTAT.addActionListener(this);
			menuitemIgnoreSTAT.setAccelerator(KeyStroke.getKeyStroke(73,2)); // CTRL+I
			menuOther.add(menuitemIgnoreSTAT);

			mainMenuBar.add( menuOther) ;

			return mainMenuBar;
		}

		private void applyAccelerators() {
			int keyMapIndex=16; // Accelerators start at 16
			#define NEXT_KEYSTROKE_FROM_KEYMAP KeyStroke.getKeyStroke( keyMap[keyMapIndex]&0xff, keyMap[keyMapIndex++]>>8 )
			menuitemConfigKeys.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemOpenROM.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemPause.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemReset.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemExit.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			enableFullScreen.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemMixFrame.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			for (int i = 0; i < 4; ++i)
				scaleRadioGroup.getItem(i).setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			keepAspectRatio.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			for (int i=0; i<4; ++i)
				interpolationRadioGroup.getItem(i).setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemIncFrameSkip.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemDecFrameSkip.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemes[0].setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemes[1].setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemes[2].setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemes[3].setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemes[4].setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemSaveState.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemLoadState.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemSaveOldestState.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEnableSound.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			for (int i = 0; i < 4; ++i)
				soundChannelGroup.getItem(i).setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemCheats.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEnableCheats.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedPlus.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedMinus.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedMul.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedDiv.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedNormal.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			NEXT_KEYSTROKE_FROM_KEYMAP; //Non Shortcut for Max Emu Speed
		}

		public void addComponentsToPane( Container contentPane ) {
			grfx=new DrawingArea( cpu.VC ); //doublebuffering
			grfx.setFocusable(true);

			// Fix(/workaround) broken X11 key repeat stupidity
			if (System.getProperty("os.name").equals("Linux"))
				grfx.addKeyListener(new TimedKeyListener(this));
			else
				grfx.addKeyListener(this);

			grfx.setDoubleBuffered(false);
			contentPane.add( grfx );
		}

		static JFrame frame;
		static JFrame fsframe;

		private void createGUI() {
			try {
				UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
			}
			catch (Exception ex) {
				System.out.println(ex);
			}

			frame = new JFrame( "JGameBoy Emulator V"+Version.str);
			fsframe = new JFrame( "JGameBoy Emulator V"+Version.str);

			frame.setDefaultCloseOperation( JFrame.DO_NOTHING_ON_CLOSE );
			fsframe.setDefaultCloseOperation( JFrame.DO_NOTHING_ON_CLOSE );

			frame.getContentPane().setLayout(null);
			fsframe.getContentPane().setLayout(null);

			fsframe.getContentPane().setBackground(Color.BLACK);

			fsframe.setUndecorated(true);

			//Set up the content pane and add swing components to it
			mainMenuBar = createJMenuBar();
			frame.setJMenuBar( mainMenuBar );
			addComponentsToPane( frame.getContentPane() );
			Toolkit toolkit = Toolkit.getDefaultToolkit();
			URL imgurl = getClass().getResource("icon.gif");
			if(imgurl!=null) {
				Image image = toolkit.getImage(imgurl);
				frame.setIconImage(image);
			}
			else {
				PRINTLN("Can't load JGBE icon!");
			}
			frame.addComponentListener(this);
			frame.addWindowListener(this);
			fsframe.addWindowListener(this);
			mainMenuBar.addMouseMotionListener(this);
			grfx.addFocusListener(this);
			fsframe.addMouseMotionListener(this);
			for (int i = 0; i < mainMenuBar.getMenuCount(); ++i)
				mainMenuBar.getMenu(i).addMouseMotionListener(this);

			frame.setResizable(false);
			frame.pack();

			/* DND */
			JavaCrossplatformnessIsAMyth transferhandler = new JavaCrossplatformnessIsAMyth();
			grfx.setTransferHandler(transferhandler);
		}

		public void showGUI() {
			Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
			Point     p = new Point();
			p.setLocation((d.getWidth()/2) - (frame.getWidth()/2), (d.getHeight()/2)-(frame.getHeight()/2));
			frame.setLocation(p);
			frame.setVisible( true );
		}

		public class JavaCrossplatformnessIsAMyth extends TransferHandler {
			private static final String URI_LIST = "uri-list";
			public boolean canImport(JComponent comp, DataFlavor[] transferFlavors) {
				for(int i=0; i< transferFlavors.length; ++i) {
					DataFlavor flavor = transferFlavors[i];
					// windows
					if (flavor.equals(DataFlavor.javaFileListFlavor)) {
						return true;
					// kde
					} else if (URI_LIST.equals( flavor.getSubType() )) {
						return true;
					}
				}
				return false;
			}

			public boolean importData(JComponent comp, Transferable t) {
				VECTOR(File) files = null;
				try {
					for(int i=0; i < t.getTransferDataFlavors().length; ++i) {
						DataFlavor flavor = t.getTransferDataFlavors()[i];
						Object obj = t.getTransferData(flavor);
						// windows
						if (DataFlavor.javaFileListFlavor.equals(flavor)) {
							files = new VECTOR(File)();
							files.addAll( (java.util.Collection)t.getTransferData(flavor) );
						// kde
						} else if (URI_LIST.equals(flavor.getSubType()) && obj instanceof String ) {
							String urilist = (String)obj;
							Scanner scanner = new Scanner(urilist.trim());
							files = new VECTOR(File)();
							while (scanner.hasNextLine()) {
								files.add(new File(new URI(scanner.nextLine()) ) );
							}
						}
					}
				} catch (Exception e) {
					e.printStackTrace();
					return false;
				}

				if(files != null) if(files.size() == 1) tryToLoadROM(files.get(0).toString());// PRINTLN(files.get(0));

				return true;
			}
		}

		boolean focus_pause = false;
		public void focusGained(FocusEvent e) {
			if (!debug)
				if(focus_pause)
					resumeEmulation(false);
		}

		public void focusLost(FocusEvent e) {
			if (!debug) {
				focus_pause = cpuRunner.isRunning();
				if(!cs.isVisible() && cpuRunner != null) // We like to keep the emu running when selecting colors
					pauseEmulation(false);
			}
		}

		boolean fulls = false;
		public void componentHidden(ComponentEvent e) {}
		public void componentMoved(ComponentEvent e) {}
		public void componentShown(ComponentEvent e) {}
		public void componentResized(ComponentEvent e) {
			if (fulls != enableFullScreen.getState()) {
				GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
				GraphicsDevice gd = ge.getDefaultScreenDevice();
				if (enableFullScreen.getState()) {
					frame.setVisible(false);

					fsframe.setJMenuBar(null);
					fsframe.getContentPane().add(mainMenuBar); // add menubar first so it gets drawn properly when it has focus (why? dunno!)
					fsframe.getContentPane().add(grfx);

					gd.setFullScreenWindow(fsframe);
				} else {
					gd.setFullScreenWindow(null);
					fsframe.setVisible(false);

					frame.setResizable(grfx.interpolation != 0);
					frame.getContentPane().add(grfx);
					frame.setJMenuBar(mainMenuBar);

					frame.setVisible(true);
				}
				fulls = enableFullScreen.getState();
			}

			Dimension psize; // screen panel size
			Dimension csize; // content pane size
			csize = (fulls ? fsframe: frame.getContentPane()).getSize();
			if (grfx.interpolation == 0) {
				psize = new Dimension(VC.nscale*160, VC.nscale*144);
				if (!fulls) {
					Dimension fsize = frame.getSize(); // frame size, including borders
					Dimension bsize = new Dimension(); // screen panel size, plus border size
					bsize.width = MAX(psize.width + (fsize.width - csize.width), frame.getPreferredSize().width);
					bsize.height = MAX(psize.height + (fsize.height - csize.height), frame.getPreferredSize().height);

					frame.setSize(bsize);
				}
			} else {
				psize = new Dimension(csize);
				if (keepAspectRatio.getState()) {
					double ratio = psize.getWidth()/psize.getHeight();
					double target = 160.0/144.0;
					if (ratio < target)
						psize.height = (int)Math.round(psize.getWidth() / target);
					else
						psize.width = (int)Math.round(psize.getHeight() * target);
				}
			}
			Rectangle trect = new Rectangle(psize);
			if (psize.width < csize.width) trect.translate((csize.width - psize.width)/2,0);
			if (psize.height < csize.height) trect.translate(0,(csize.height - psize.height)/2);
			grfx.setBounds(trect);
			if (fulls)
				mainMenuBar.setBounds(new Rectangle(mainMenuBar.getPreferredSize()));
			grfx.repaint();
			saveConfig();
		}

		static public void pauseEmulation(boolean verbose) {
			if(cpuRunner!=null) {
				cpuRunner.suspend();
				if(verbose) addOSDLine("Paused gameboy");
			}
		}

		static public void resumeEmulation(boolean verbose) {
			if((cpuRunner!=null)&&(cart!=null)) {
				cpuRunner.resume();
				if(verbose) addOSDLine("Unpaused gameboy");
			}
		}

		public void actionPerformed( ActionEvent e ) {
/*				JMenuItem source = ( JMenuItem )( e.getSource() );
				String s = "Menu Item source: " + source.getText()
			           + " (an instance of " + getClassName( source ) + ")";
				PRINTLN(s);*/
			boolean configStateChanged = false;
			if (e.getSource().equals( menuitemIgnoreSTAT )) {
				VC.allow_writes_in_mode_2_3 = menuitemIgnoreSTAT.getState();
				configStateChanged = true;
			}
			else if (e.getSource().equals( menuitemExit)) {
				windowClosed(null);
			}
			else if (scaleRadioGroup.contains(e.getSource())) {
				int idx = scaleRadioGroup.getSelectedIndex();
				VC.nscale = idx+1;
				addOSDLine("Set scaling: Scale"+VC.nscale+"x");
				componentResized(null);
				configStateChanged = true;
			}
			else if (interpolationRadioGroup.contains(e.getSource())) {
				int idx = interpolationRadioGroup.getSelectedIndex();
				frame.setResizable(idx != 0);
				keepAspectRatio.setEnabled(idx != 0);
				grfx.interpolation = idx;
				componentResized(null);
				configStateChanged=true;
			}
			else if (e.getSource().equals(keepAspectRatio)) {
				componentResized(null);
				configStateChanged=true;
			}
			else if (e.getSource().equals(enableFullScreen)) {
				componentResized(null);
				configStateChanged=true;
			}
			else if (e.getSource().equals( menuitemIncFrameSkip )) {
				++VC.fskip;
				addOSDLine("Increased frameskip: "+VC.fskip);
				configStateChanged = true;
			}
			else if (e.getSource().equals( menuitemDecFrameSkip )) {
				if (VC.fskip>1) --VC.fskip;
				addOSDLine("Decreased frameskip: "+VC.fskip);
				configStateChanged = true;
			}
			else if (e.getSource().equals( menuitemEnableSound )) {
				cpu.AC.isMuted = !menuitemEnableSound.getState();
				addOSDLine( cpu.AC.isMuted?"Disabled sound":"Enabled sound");
				configStateChanged = true;
			}
			else if (soundChannelGroup.contains(e.getSource())) {
				int channel = soundChannelGroup.indexOf(e.getSource())+1;
				boolean enabled = cpu.AC.toggleChannelOnOff(channel);
				addOSDLine((enabled ? "Enabled" : "Disabled") + " soundchannel " + channel);
				configStateChanged = true;
			}
			else if (e.getSource().equals( menuitemEnableCheats)) {
				cheatcodes.ToggleCheats(cart);
				addOSDLine("Cheats codes are now " + (cheatcodes.UseCheats?"enabled":"disabled") );
				configStateChanged = true;
			}
			else if (e.getSource().equals( menuitemConfigKeys )) {
				keyConfigDialog k=new keyConfigDialog(frame, keyMap);
				pauseEmulation(false);
				k.getKeyCodes();
				saveKeyBinds();
				applyAccelerators();
				resumeEmulation(false);
			}
#ifdef SCALEBUILDER
			else if (e.getSource().equals( menuitemScaleBuilder)) {
				ScaleBuilder sb = new ScaleBuilder(frame);
				//sb.showOpenDialog();
			}
#endif
			else if (e.getSource().equals( menuitemCheats)) {
				pauseEmulation(false);
				cheatcodes.editCodes();
				cheatcodes.applyCheatCodes(cart);
				resumeEmulation(false);
				addOSDLine("ZOMG CHEATER!!!!");
			}
			else if(e.getSource().equals( menuitemUseBIOS )) {
				if (menuitemUseBIOS.getState()) cart.loadBios(biosfilename);
				else cart.loadBios("");
				configStateChanged = true;
			}
			else if(e.getSource().equals( menuitemSetBIOS )) {
				JFileChooser fc = new JFileChooser(".");
				fc.showOpenDialog(frame);
				File selFile = fc.getSelectedFile();
				if(selFile != null) {
					if(selFile.length() != 256) JOptionPane.showMessageDialog(null,
					                            "This file's size is not equal to 256 bytes!",
					                            "Invalid BIOS Rom",
					                            JOptionPane.INFORMATION_MESSAGE);
					else {
						biosfilename = selFile.getAbsolutePath();
						if (menuitemUseBIOS.getState()) cart.loadBios(biosfilename);
						else cart.loadBios("");
						configStateChanged = true;
					}
				}
			}
			else if(e.getSource().equals( menuitemOpenROM )) {
				JFileChooser fc;
				if (rcFiles.size() > 0) {
					String lastpath = (String)rcFiles.get(0);
					int slashPos = lastpath.lastIndexOf(File.separator);
					lastpath = lastpath.substring(0, slashPos+1);
					fc = new JFileChooser(lastpath);
				}
				else
					fc = new JFileChooser(".");

				// Show open dialog; this method does not return until the dialog is closed
				fc.showOpenDialog(frame);
				File selFile = fc.getSelectedFile();
				if(selFile != null) {
					tryToLoadROM(selFile.getAbsolutePath());
				}
			}
			else if(e.getSource().equals( menuitemLinkServe )) {
				try {
					CPU.serveLink();
				}
				catch (IOException ioe) {
					JOptionPane.showMessageDialog(frame, "Failed: " + ioe.getMessage(), "Error!", JOptionPane.ERROR_MESSAGE);
				}
			}
			else if(e.getSource().equals( menuitemLinkSever )) {
				CPU.severLink();
			}
			else if(e.getSource().equals( menuitemLinkClient )) {
				try {
					CPU.clientLink((String)JOptionPane.showInputDialog(frame, (Object)"Enter host address", "Link setup", JOptionPane.QUESTION_MESSAGE, null, null, "localhost"));
				}
				catch (IOException ioe) {
					JOptionPane.showMessageDialog(frame, "Failed: " + ioe.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
				}
			}
			else if(e.getSource().equals( menuitemSaveState )) {
				if (!CPU.canRun()) return;
				pauseEmulation(false);
				addOSDLine("Saving State "+selectedState);
				try {
					String stname = FHandler.JGBEDir("savestates");
					stname += curcartname + ".st" + selectedState;
					DataOutputStream dostream = FHandler.getDataOutputStream(stname);
					CPU.saveState(dostream);
					dostream.close();
				}
				catch (java.io.IOException ioe) {
					PRINTLN("Error saving state! ");
					PRINTLN(ioe.getMessage());
				};
				menuitemSpeedRunRecord.setState(cpu.keyHistoryEnabled);
				menuitemSpeedRunPlay.setState(cpu.playbackHistoryIndex != -1);
				resumeEmulation(false);
			}
			else if(e.getSource().equals( menuitemLoadState )) {
				if (!CPU.canRun()) return;
				pauseEmulation(false);
				try {
					String stname = FHandler.JGBEDir("savestates") + curcartname + ".st" + selectedState;
					DataInputStream distream = FHandler.getDataInputStream(stname);
					CPU.loadState(distream);
					distream.close();
					addOSDLine("Loaded state "+selectedState);
				}
				catch (java.io.IOException ioe) {
					addOSDLine("Failed to load state "+selectedState);
				};
				resumeEmulation(false);
				if(cpu.keyHistoryEnabled) addOSDLine("Note: Speedrun in progress");
				menuitemSpeedRunRecord.setState(cpu.keyHistoryEnabled);
				menuitemSpeedRunPlay.setState(cpu.playbackHistoryIndex != -1);
			}
			else if(e.getSource().equals( menuitemSaveOldestState )) {
				if (!CPU.canRun()) return;
				pauseEmulation(false);
				selectedState = saveStateOrder.remove(0);
				saveStateOrder.add(selectedState);
				addOSDLine("Saving To Oldest State " + selectedState);
				try {
					String stname = FHandler.JGBEDir("savestates");
					stname += curcartname + ".st" + selectedState;
					DataOutputStream dostream = FHandler.getDataOutputStream(stname);
					CPU.saveState(dostream);
					dostream.close();
				}
				catch (java.io.IOException ioe) {
					PRINTLN("Error saving state! ");
					PRINTLN(ioe.getMessage());
				};
				menuitemSpeedRunRecord.setState(cpu.keyHistoryEnabled);
				menuitemSpeedRunPlay.setState(cpu.playbackHistoryIndex != -1);
				resumeEmulation(false);
			}
			else if(e.getSource().equals( menuitemPause )) {
				if(cpuRunner.isRunning())
					pauseEmulation(true);
				else
					resumeEmulation(true);
			}
			else if(e.getSource().equals( menuitemReset )) {
				pauseEmulation(false);
				cpu.reset(menuitemUseBIOS.getState());
				resumeEmulation(false);
				addOSDLine("Reset gameboy");
			}
			else if(e.getSource().equals( menuitemSpeedRunRecord )) {
				if(cpu.keyHistoryEnabled) {
					addOSDLine("Stopped recording of your speedrun");
					pauseEmulation(false);
					cpu.keyHistoryEnabled = false;
					resumeEmulation(false);
				}
				else {
					menuitemSpeedRunPlay.setState(false);
					addOSDLine("Now recording speedrun");
					pauseEmulation(false);
					cpu.reset(false);
					cpu.keyHistoryEnabled = true;
					resumeEmulation(false);
				}
				menuitemSpeedRunRecord.setState(cpu.keyHistoryEnabled);
				menuitemSpeedRunPlay.setState(cpu.playbackHistoryIndex != -1);
			}
			else if(e.getSource().equals( menuitemSpeedRunPlay ) || e.getSource().equals( menuitemSpeedRunPlayWithOutput )) {
				menuitemSpeedRunRecord.setState(false);
				pauseEmulation(false);
				IntVector hist = cpu.keyHistory;
				cpu.keyHistory = new IntVector();
				cpu.reset(false);
				cpu.keyHistory = hist;
				cpu.playbackHistoryIndex = 0;
				cpu.keyHistoryEnabled = false;
				if(e.getSource().equals( menuitemSpeedRunPlayWithOutput )) {
					if(menuitemSpeedRunPlayWithOutput.getState()) {
						JFileChooser fcv = new JFileChooser(".");
						fcv.setDialogTitle("Save video dump");
						File vidFile;
						fcv.showSaveDialog(frame);
						vidFile = fcv.getSelectedFile();

						JFileChooser fca = new JFileChooser(".");
						fca.setDialogTitle("Save audio dump");
						File audFile;
						fca.showSaveDialog(frame);
						audFile = fca.getSelectedFile();

						if(vidFile != null && audFile != null) {
							try {
								speedRunPlayWithOutputVideoStream = FHandler.getDataOutputStream(vidFile.getAbsolutePath());
								DataOutputStream audstr = FHandler.getDataOutputStream(audFile.getAbsolutePath());

								int SampleRate = 44100;
								int Channels = 2;
								int BitsPerSample = 8;
								int ByteRate = SampleRate * Channels * BitsPerSample / 8;
								int BlockAlign = Channels * BitsPerSample / 8;
								int hdr[] = {
									'R', 'I', 'F', 'F',
									0,   0,   0,   0,
									'W', 'A', 'V', 'E',
									'f', 'm', 't', ' ',
									16,   0,   0,   0,
									1,   0,
									(Channels&0xff),   ((Channels>>8)&0xff),
									(SampleRate&0xff), ((SampleRate>>8)&0xff), ((SampleRate>>16)&0xff), ((SampleRate>>24)&0xff),
									(ByteRate&0xff), ((ByteRate>>8)&0xff), ((ByteRate>>16)&0xff), ((ByteRate>>24)&0xff),
									(BlockAlign&0xff),   ((BlockAlign>>8)&0xff),
									(BitsPerSample&0xff),   ((BitsPerSample>>8)&0xff),
									'd', 'a', 't', 'a',
									0,   0,   0,   0,
									0,   0,   0,   0,
								};

								PRINTLN(hdr.length);
								for (int i = 0; i < hdr.length; ++i)
									audstr.writeByte(hdr[i]);

								//fwrite(hdr, 1, 48, f);

								audioDriver.reset();
								audioDriver.setDumpStream(audstr);

							}
							catch (IOException ee) {
								speedRunPlayWithOutputVideoStream = null;
								JOptionPane.showMessageDialog(frame,
								                              "Error while opening file, recording will fail:\n"+ee.getMessage(),
								                              "Error!",
								                              JOptionPane.ERROR_MESSAGE);
							}
						}
					}
					else {
						speedRunPlayWithOutputVideoStream = null;
						audioDriver.setDumpStream(null);
					}
				}
				resumeEmulation(false);
				menuitemSpeedRunPlay.setState(cpu.playbackHistoryIndex != -1);
			}
			else if(e.getSource().equals( menuitemEmuSpeedPlus )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = 0.25 + cs;
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedMinus )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = Math.max(cs-0.25,0);
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedMul )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = 1.25 * cs;
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedDiv )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = 0.75 * cs;
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedNormal )) {
				CPU.AC.setSpeed(1.0);
				addOSDLine("EmuSpeed: 100%");
			}
			else if(e.getSource().equals( menuitemMixFrame )) {
				CPU.VC.MixFrames=!CPU.VC.MixFrames;
				addOSDLine((CPU.VC.MixFrames?"Enabled":"Disabled")+" Mix Frame mode");
				configStateChanged=true;
			}
			#define SELECT_COLOR_MENU(x) for(int i=0; i<menuitemColorSchemes.length; ++i) \
			                             	menuitemColorSchemes[i].setState(false); \
			                             menuitemColorSchemes[x].setState(true)
			else if(e.getSource().equals( menuitemColorSchemes[0] )) {
				int[][] c={ {0xa0, 0xe0, 0x20},	// WHITE
										{0x70, 0xb0, 0x40},  // LIGHTGRAY
										{0x40, 0x70, 0x32},  // DARKGRAY
										{0x10, 0x50, 0x26}}; // BLACK
				cpu.VC.setGrayShades(c);
				cs.setVisible( false );
				configStateChanged = true;
				SELECT_COLOR_MENU( 0 );
			}
			else if(e.getSource().equals( menuitemColorSchemes[1] )) { /* Palette for GameBoy Pocket/Light */
				int[][] c={ {0xC4,0xCF,0xA1},	// WHITE
										{0x8B,0x95,0x6D},  // LIGHTGRAY
										{0x6B,0x73,0x53},  // DARKGRAY
										{0x41,0x41,0x41}}; // BLACK
				cpu.VC.setGrayShades(c);
				cs.setVisible( false );
				configStateChanged = true;
				SELECT_COLOR_MENU( 1 );
			}
			else if(e.getSource().equals( menuitemColorSchemes[2] )) {
				int[][] c={ {0xf8, 0xf8, 0xf8},	// WHITE
										{0xa8, 0xa8, 0xa8},  // LIGHTGRAY
										{0x60, 0x60, 0x60},  // DARKGRAY
										{0x00, 0x00, 0x00}}; // BLACK
				cpu.VC.setGrayShades(c);
				cs.setVisible( false );
				configStateChanged = true;
				SELECT_COLOR_MENU( 2 );
			}
			else if(e.getSource().equals( menuitemColorSchemes[3] )) {
				int[][] c={ {0xc5, 0xc5, 0xc5},	// WHITE
										{0x9a, 0x9a, 0x9a},  // LIGHTGRAY
										{0x61, 0x61, 0x61},  // DARKGRAY
										{0x3f, 0x3f, 0x3f}}; // BLACK
				cpu.VC.setGrayShades(c);
 				cs.setVisible( false );
				configStateChanged = true;
				SELECT_COLOR_MENU( 3 );
			}
			else if (e.getSource().equals( menuitemColorSchemes[4] )) {
				if ( !cpu.isCGB() ) {
// 					if (!loading)
						cs.setVisible( true );
					configStateChanged = true;
					SELECT_COLOR_MENU( 4 );
				}
				else {
					JOptionPane.showMessageDialog(frame,
                                        "You are not allowed to change colors",
                                        "color error",
					                              JOptionPane.ERROR_MESSAGE);
				}
			}
			else if(e.getSource().equals( menuitemToggleRemoteKeys )) {
				cpu.useRemoteKeys = !cpu.useRemoteKeys;
				addOSDLine("Remote Keys: "+(cpu.useRemoteKeys?"Enabled":"Disabled"));
			}
			else if(e.getSource().equals( menuitemShowAdvancedAudioPropertiesDialog )) {
				pauseEmulation(false);
				advancedAudioPropertiesDialog.showWindow();
				resumeEmulation(false);
			}
			else if (savestateRadioGroup.contains(e.getSource())) {
				int idx = savestateRadioGroup.getSelectedIndex();
				selectedState = idx;
				addOSDLine("Selected State "+selectedState);
			}
			else { //timer?
				if(menuItems!=null)
					for (int i = 0; i < menuItems.length; ++i) {
						if (e.getSource().equals(menuItems[i]))
						tryToLoadROM((String)rcFiles.get(i));
				}

				if((--titleUpdateCountDown) <= 0) {
				long ctime = System.nanoTime();
				long timeLapse =  ctime - FPSTimeMillis;
				FPSTimeMillis = ctime;

				double afps=fps/(timeLapse/1000000000.0);
				long ncycles = CPU.TotalCycleCount - FPSCPUCycles;
				FPSCPUCycles = CPU.TotalCycleCount;
				double emuspeed =  ((int)((((float)ncycles)/((4194304*timeLapse*(CPU.doublespeed?2:1))/1000000000.0f))*10000.0f))/100.0;
				String titlestr = (cart != null)?" - " + cart.getTitle():"";
				frame.setTitle(Format142.strformat( "JGBE V"+Version.str+" - %05.02f fps / %06.02f%%"+titlestr,new double[] {(((int)(afps*100))/((double)100)), (double)emuspeed}));
				fps = 0;
				titleUpdateCountDown=4;
				}

				if (deactcount > 0 && --deactcount == 0 && enableFullScreen.getState()) {
					--deactcount;
					enableFullScreen.setState(false);
					componentResized(null);
				}
				if((osdTimer==0)&&(osdLines.size()>0)) {
					osdLines.remove(0);
				} else --osdTimer;
			}
			if (configStateChanged ) saveConfig();
		}
		long FPSTimeMillis = System.nanoTime();
		long FPSCPUCycles = CPU.TotalCycleCount;
		long deactcount = 0;

		public void itemStateChanged( ItemEvent e ) {
			ASSERT(false); //What does this function do?
			JMenuItem source = ( JMenuItem )( e.getSource() );
			String s = "Menu Item source: " + source.getText()
			           + " (an instance of " + getClassName( source ) + ")"
			           + "\n"
			           + "    State of check Box: "
			           + (( e.getStateChange() == ItemEvent.SELECTED ) ?
			              "selected":"unselected" );
			PRINTLN( s );
		}

		public void keyTyped(KeyEvent e) {}

		static final int[] keyMasks = {
			BUTTON_UP,
			BUTTON_DOWN,
			BUTTON_LEFT,
			BUTTON_RIGHT,
			BUTTON_A,
			BUTTON_B,
			BUTTON_START,
			BUTTON_SELECT,
		};

		public void keyReleased(KeyEvent e) {
			int keyCode = e.getKeyCode();
			int keyModifiers = e.getModifiers();
			int keyState = keyCode | (keyModifiers << 8);

			for(int i=0; i<8; ++i) {
				if((keyMap[i]&0xff)==keyCode) { //Check just the keycode, modifiers don't matter for release
					cpu.releaseButton(keyMasks[i]);
					return;
				}
			}
			for(int i=8; i<16; ++i) {
				if(keyMap[i]==keyState) {
					cpu.releaseRemoteButton(keyMasks[i&7]);
					return;
				}
			}
			if(keyCode == keyMap[nrOfShortCuts+16-1]) {
				cpu.AC.speedHax = false;
			}
		}

		public void keyPressed(KeyEvent e) {
			int keyCode = e.getKeyCode();
			int keyModifiers = e.getModifiers();
			int keyState = keyCode | (keyModifiers << 8);

			for(int i=0; i<8; ++i) {
				if(keyMap[i]==keyState) {
					cpu.pressButton(keyMasks[i]);
					return;
				}
			}
			for(int i=8; i<16; ++i) {
				if(keyMap[i]==keyState) {
					cpu.pressRemoteButton(keyMasks[i&7]);
					return;
				}
			}
			if(keyCode == keyMap[nrOfShortCuts+16-1]) {
				cpu.AC.speedHax = true;
			}
		}

		public void makeRcFilesMenuItems() {
			int staticMenuItems = 4;
			ASSERT(menuFile != null); //Should never happen
			if (menuFile != null) {
				while (menuFile.getItemCount() > staticMenuItems) {
					menuFile.remove(staticMenuItems);
				}
				menuItems = new JMenuItem[rcFiles.size()];

				menuFile.addSeparator();
				for (int i = 0; i < rcFiles.size(); ++i) {
					String lname = (String)rcFiles.get(i);
					String name = lname.substring(lname.lastIndexOf(File.separator) + 1);
					menuItems[i] = new JMenuItem(name);
					menuFile.add(menuItems[i]);
					menuItems[i].addActionListener(this);
				}
			}
		}


		// Returns the class name, no package info
		protected static String getClassName( Object o ) {
			String classString = o.getClass().getName();
			int dotIndex = classString.lastIndexOf( "." );
			return classString.substring( dotIndex+1 );	//Returns only Class name
		}

		public void loadRCFiles() {
			try {
				String rcfilename = FHandler.JGBEDir("") + "rcfiles.log";
				BufferedReader in = new BufferedReader(new FileReader(rcfilename));
				String str;
				rcFiles.clear();
				while ((str = in.readLine()) != null) {
						rcFiles.add(str);
				}
				in.close();
			} catch (IOException e) {
				PRINTLN("error reading rcfiles.log");
			}
		}

		public void saveRCFiles() {
			try {
				String rcfilename = FHandler.JGBEDir("") + "rcfiles.log";
				BufferedWriter out = new BufferedWriter(new FileWriter(rcfilename));
				String str;
				int num = MIN(10, rcFiles.size());
				for (int i = 0; i < num; ++i) {
					str = (String)rcFiles.get(i);
					out.write(str, 0, str.length());
					out.newLine();
				}
				out.close();
			} catch (IOException e) {
				PRINTLN("error writing rcfiles.log");
			}
			makeRcFilesMenuItems();
		}


		private boolean allowSaves = false; // Do not allow saves before we have loaded the config
		public void saveConfig() {
			if(!allowSaves) return;
			try {
				String filename = FHandler.JGBEDir("") + "jgbe.conf";
				DataOutputStream dostream = FHandler.getDataOutputStream(filename);
				int saveversion = SL_GUI_SWING_SAVE_VERSION; //change when changing savestate format
				dostream.writeInt(SL_GUI_SWING_MAGIX);
				dostream.writeInt(SL_GUI_SWING_SAVE_VERSION);
				int compressionmethod = 1; // GZIP compression
				DeflaterOutputStream zostream = null;
				dostream.writeInt(compressionmethod);
				switch (compressionmethod) {
					// no compression
					case 0: break;
					// GZIP compression
					case 1: {
						zostream = new GZIPOutputStream(dostream);
						dostream = new DataOutputStream(zostream);
					}; break;
					default: ASSERT(false);
				}
				stateSaveLoad(true, saveversion, dostream, null);
				if (zostream != null) {
					dostream.flush();
					zostream.finish();
				}
				dostream.close();
			}
			catch(IOException e) { PRINTLN("Warning: failed to save GUI config: " + e.toString()); }
		}

		public void loadConfig() {
			setGUIDefaults();
			try {
				String filename = FHandler.JGBEDir("") + "jgbe.conf";
				DataInputStream distream = FHandler.getDataInputStream(filename);
				int loadversion;
				int magix = distream.readInt();
				if (magix == SL_GUI_SWING_MAGIX) {
					loadversion = distream.readInt();
					if ((loadversion < SL_LOAD_MIN_VERSION) || (loadversion > SL_LOAD_MAX_VERSION))
						return;
					if (loadversion != SL_GUI_SWING_SAVE_VERSION)
						PRINTLN("loading config with old version:"+loadversion);

					int compressionmethod = distream.readInt();
					switch (compressionmethod) {
						// no compression
						case 0: break;
						// GZIP compression
						case 1: distream = new DataInputStream(new GZIPInputStream(distream)); break;
						default: PRINTLN("GUI config: unknown compression method:"+compressionmethod);
					}
					stateSaveLoad(false, loadversion, null, distream);
				}
			} catch(IOException e) { PRINTLN("Warning: failed to load GUI config: " + e.toString()); }
			allowSaves = true;
		}

		void setGUIDefaults() { //TODO: Currently just the old loadConfig w/o the file loading part
			boolean runbiosonreset = false;
			boolean[] soundchannelactive = new boolean[4];
			for(int i=0; i<4; ++i) soundchannelactive[i] = true;
			boolean usecheats = true;
			int colorType = 0;
			biosfilename = "";
			VC.nscale = 2;
			int adChannels = 2;
			String adName = "None";
			String adVendor = "None";
			String adDescription = "None";
			String adVersion = "None";
			int adSampleRate = 44100;   // Default for most soundcards
			int adOutputInterval = 735; // 44100/60, once per frame
			int adBufferSize = 2048;    // no need to buffer big enough to avoid underruns
			int interpolationRadioGroupsetSelectedIndex=0;
			boolean keepAspectRatiosetEnabled=false;
			boolean keepAspectRatiosetState=true;
			boolean enableFullScreensetEnabled=true;
			boolean enableFullScreensetState=false;
			boolean menuitemMixFramesetState=false;
			Dimension fsize = frame.getSize();
			int fsizewidth = fsize.width;
			int fsizeheight = fsize.height;
			grfx.setPreferredSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
			grfx.setSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
			menuitemIgnoreSTAT.setState(cpu.VC.allow_writes_in_mode_2_3);
			frame.pack();
			menuitemUseBIOS.setState(runbiosonreset);
			menuitemEnableSound.setState(!cpu.AC.isMuted);
			for (int i = 0; i < 4; ++i) {
				cpu.AC.setChannelActive(i+1, soundchannelactive[i]);
				((JCheckBoxMenuItem)soundChannelGroup.get(i)).setState(soundchannelactive[i]);
			}
			actionPerformed(new ActionEvent(menuitemColorSchemes[colorType], 0, ""));
			scaleRadioGroup.setSelectedIndex(VC.nscale-1);
			if(cheatcodes==null) cheatcodes = new CheatCodeEditor(frame, curcartname);
			cheatcodes.useCheats(usecheats);
			menuitemEnableCheats.setState(usecheats);

			if(audioDriver!=null) {
				audioDriver.setMixerInfo(adName, adVendor, adDescription, adVersion);
				audioDriver.setChannels(adChannels);
				audioDriver.setBufferSize(adBufferSize);
				audioDriver.setOutputInterval(adOutputInterval);
				audioDriver.setSampleRate(adSampleRate);
			}

			interpolationRadioGroup.setSelectedIndex(interpolationRadioGroupsetSelectedIndex);
			keepAspectRatio.setEnabled(keepAspectRatiosetEnabled);
			keepAspectRatio.setState(keepAspectRatiosetState);
			enableFullScreen.setEnabled(enableFullScreensetEnabled);
			enableFullScreen.setState(enableFullScreensetState);
			menuitemMixFrame.setState(menuitemMixFramesetState);
			CPU.VC.MixFrames=menuitemMixFramesetState;
			fsize = new Dimension(fsizewidth, fsizeheight);
			frame.setPreferredSize(fsize);
			frame.pack();
			frame.setPreferredSize(new Dimension(0,0));
			actionPerformed(new ActionEvent(interpolationRadioGroup.get(interpolationRadioGroupsetSelectedIndex), 0, ""));
		}

		SAVELOAD_FUNCTION {
			SL_BOOL  (cpu.AC.isMuted);
			SL_STRING(biosfilename);
			SL_GETSET(BOOL, menuitemUseBIOS, getState, setState);
			SL_INT   (VC.nscale);
			SL_GETSET(INT, scaleRadioGroup, getSelectedIndex, setSelectedIndex);
			SL_INT   (VC.fskip);

			SL_GETSET(INT, interpolationRadioGroup, getSelectedIndex, setSelectedIndex);
			if(SL_LOAD)
				actionPerformed(new ActionEvent(interpolationRadioGroup.get(interpolationRadioGroup.getSelectedIndex()), 0, ""));
			SL_GETSET(BOOL, keepAspectRatio, isEnabled, setEnabled);
			SL_GETSET(BOOL, keepAspectRatio, getState, setState);
			SL_GETSET(BOOL, enableFullScreen, isEnabled, setEnabled);
			SL_GETSET(BOOL, enableFullScreen, getState, setState);
			SL_GETSET(BOOL, menuitemMixFrame, getState, setState);
			CPU.VC.MixFrames=menuitemMixFrame.getState();

			{
				int[][][] gs = VC.getGrayShades();
				SL_ARR_3D(INT, gs, 3, 4, 3);
				if(SL_LOAD)
					VC.setGrayShades(gs);
				for(int i = 0; i < menuitemColorSchemes.length; ++i) {
					SL_GETSET(BOOL, menuitemColorSchemes[i], getState, setState);
					if(SL_LOAD && menuitemColorSchemes[i].getState())
						actionPerformed(new ActionEvent(menuitemColorSchemes[i], 0, ""));
				}

				SL_GETSET(BOOL, menuitemIgnoreSTAT, getState, setState);
				VC.allow_writes_in_mode_2_3 = menuitemIgnoreSTAT.getState();
			}

			{
				SL_BOOL(cheatcodes.UseCheats);
				menuitemEnableCheats.setState(cheatcodes.UseCheats);
			}

			{
				boolean[] soundchannelactive = new boolean[4];
				if (SL_SAVE)
					for (int i = 0; i < 4; ++i)
						soundchannelactive[i] = cpu.AC.channelActive(i+1);
				SL_ARR(BOOL,soundchannelactive,4)
				menuitemEnableSound.setState(!cpu.AC.isMuted);
				if (SL_LOAD)
					for (int i = 0; i < 4; ++i) {
						cpu.AC.setChannelActive(i+1, soundchannelactive[i]);
						((JCheckBoxMenuItem)soundChannelGroup.get(i)).setState(soundchannelactive[i]);
					}
			}

			{
				String adName = "None", adVendor = "None", adDescription = "None", adVersion = "None";
				int    adChannels = 2, adSampleRate = 44100, adOutputInterval = 735, adBufferSize = 2048;
				if(SL_SAVE && audioDriver!=null) {
					adName           = audioDriver.getMixerInfo().getName();
					adVendor         = audioDriver.getMixerInfo().getVendor();
					adDescription    = audioDriver.getMixerInfo().getDescription();
					adVersion        = audioDriver.getMixerInfo().getVersion();
					adChannels       = audioDriver.getChannels();
					adBufferSize     = audioDriver.getBufferSize();
					adOutputInterval = audioDriver.getOutputInterval();
					adSampleRate     = audioDriver.getSampleRate();
				}
// 				PRINTLN("AudioDriver: name="+adName+ " vendor="+adVendor+" desc="+adDescription+" version="+adVersion+" channels="+adChannels+" buffer="+adBufferSize+" output="+adOutputInterval+" samples="+adSampleRate);
				SL_STRING(adName);
				SL_STRING(adVendor);
				SL_STRING(adDescription);
				SL_STRING(adVersion);
				SL_INT(adChannels);
				SL_INT(adBufferSize);
				SL_INT(adOutputInterval);
				SL_INT(adSampleRate);
				if(SL_LOAD && audioDriver!=null) {
					audioDriver.setMixerInfo(adName, adVendor, adDescription, adVersion);
					audioDriver.setChannels(adChannels);
					audioDriver.setBufferSize(adBufferSize);
					audioDriver.setOutputInterval(adOutputInterval);
					audioDriver.setSampleRate(adSampleRate);
				}
			}

			{
				int fsizewidth = 0;
				int fsizeheight = 0;
				if(SL_SAVE) {
					Dimension fsize  = frame.getSize();
					fsizewidth       = fsize.width;
					fsizeheight      = fsize.height;
				}
				SL_INT(fsizewidth);
				SL_INT(fsizeheight);
				if(SL_LOAD) {
					Dimension fsize = new Dimension(fsizewidth, fsizeheight);
					frame.setPreferredSize(fsize);
					frame.pack();
					frame.setPreferredSize(new Dimension(0,0));
				}
			}
		}

		private void updateSaveStateOrder() {
			saveStateOrder.clear();
			long[] modTimes = new long[10];
			try {
				for (int i = 0; i < 10; ++i) {
					String stname = FHandler.JGBEDir("savestates");
					stname += curcartname + ".st" + i;
					File sf = new File(stname);
					long modTime = sf.lastModified();
					//PRINTLN(modTime);
					ASSERT(modTime >= 0);
					modTime = modTime & 0xFFFFFFF0;
					//PRINTLN(modTime);
					modTimes[i] = modTime + i;
				}
			} catch (Exception e) {
				saveStateOrder = null;
			}
			Arrays.sort(modTimes);
			for (int i = 0; i < 10; ++i) {
				saveStateOrder.add((int)(modTimes[i] & 0xF));
				//PRINTLN(modTimes[i] & 0xF);
			}
		}

		private void tryToLoadROM(String filename) {
			//Disable Logo
			logo = null;
			pauseEmulation(false);
			Cartridge tcart=new Cartridge(filename);
			if (menuitemUseBIOS.getState())
				tcart.loadBios(biosfilename);
			else
				tcart.loadBios("");
			String[] messages = { "[Missing an error message here]" };
			switch(tcart.getStatus(messages)) {
				case Cartridge.STATUS_NONFATAL_ERROR: {
					JOptionPane.showMessageDialog(frame, "WARNING:\n"+messages[0], "Warning!", JOptionPane.WARNING_MESSAGE);
				} /* Fallthrough intentional */
				case Cartridge.STATUS_OK: {
					cart = tcart;
					CPU.loadCartridge(cart);
					updateCartName(filename);
					boolean b = (cheatcodes==null) ? false : cheatcodes.UseCheats;
					cheatcodes = new CheatCodeEditor(frame, curcartname);
					cheatcodes.useCheats(b);
					cheatcodes.applyCheatCodes(cart);
					updateSaveStateOrder();
					addOSDLine("loaded Rom: " + curcartname);
				} break;
				default: { //error loading file as ROM
				JOptionPane.showMessageDialog(frame, "There was an error loading this ROM!\n("+messages[0]+")" , "Error!", JOptionPane.ERROR_MESSAGE);
				} break;
			}
			resumeEmulation(false);
		}

		#define PRINT_KEY_DEFAULT PRINTLN("keyMap[Magix++]="+keyMap[i]+"; // "+(keyMap[i]>>8>0 ? \
		                                  KeyEvent.getKeyModifiersText(keyMap[i]>>8)+"+" : "") +\
		                                  KeyEvent.getKeyText(keyMap[i]&0xff))
		private void saveKeyBinds() {
			DataOutputStream distream=null;
			try {
				String path = FHandler.JGBEDir("") + "keys.conf";
				FileOutputStream fistream = new FileOutputStream(path);
				distream = new DataOutputStream(fistream);
				for(int i=0; i<16+nrOfShortCuts; ++i) {
					distream.writeInt(keyMap[i]);
// 					PRINT_KEY_DEFAULT;
				}
			}
			catch(IOException e) { //File not found or error reading it
					JOptionPane.showMessageDialog(frame,
                                        "Could not save keybinds!",
                                        "Error",
					                              JOptionPane.ERROR_MESSAGE);
			}
			finally {
				try {
					distream.close();
				}
				catch(Exception e) {
				}
			}
		}

		private void loadKeyBinds() {
			DataInputStream distream=null;
			try {
				String path = FHandler.JGBEDir("") + "keys.conf";
				FileInputStream fistream = new FileInputStream(path);
				distream = new DataInputStream(fistream);
				for(int i=0; i<16+nrOfShortCuts; ++i) {
						keyMap[i] = distream.readInt();
				}
			}
			catch(IOException e) { //File not found or error reading it
				pauseEmulation(false);
				JOptionPane.showMessageDialog(frame,
					"Keys need to be configured",
					"Warning",
					JOptionPane.WARNING_MESSAGE);
				generateDefaultKeyBinds();
				keyConfigDialog k=new keyConfigDialog(frame,keyMap);
				k.getKeyCodes();
				saveKeyBinds();
				resumeEmulation(false);
			}
			finally {
				try {
					applyAccelerators();
					distream.close();
				}
				catch(Exception e) {
				}
			}
		}

		private void generateDefaultKeyBinds() {
			int Magix = 0;
			keyMap[Magix++]=38; // Up
			keyMap[Magix++]=40; // Down
			keyMap[Magix++]=37; // Left
			keyMap[Magix++]=39; // Right
			keyMap[Magix++]=90; // Z
			keyMap[Magix++]=88; // X
			keyMap[Magix++]=61; // Equals
			keyMap[Magix++]=45; // Minus
			keyMap[Magix++]=73; // I
			keyMap[Magix++]=75; // K
			keyMap[Magix++]=74; // J
			keyMap[Magix++]=76; // L
			keyMap[Magix++]=91; // Open Bracket
			keyMap[Magix++]=93; // Close Bracket
			keyMap[Magix++]=222; // Quote
			keyMap[Magix++]=59; // Semicolon
			keyMap[Magix++]=556; // Ctrl+Comma
			keyMap[Magix++]=591; // Ctrl+O
			keyMap[Magix++]=19; // Pause
			keyMap[Magix++]=594; // Ctrl+R
			keyMap[Magix++]=593; // Ctrl+Q
			keyMap[Magix++]=2058; // Alt+Enter
			keyMap[Magix++]=589; // Ctrl+M
			keyMap[Magix++]=561; // Ctrl+1
			keyMap[Magix++]=562; // Ctrl+2
			keyMap[Magix++]=563; // Ctrl+3
			keyMap[Magix++]=564; // Ctrl+4
			keyMap[Magix++]=2625; // Ctrl+Alt+A
			keyMap[Magix++]=305; // Shift+1
			keyMap[Magix++]=306; // Shift+2
			keyMap[Magix++]=307; // Shift+3
			keyMap[Magix++]=308; // Shift+4
			keyMap[Magix++]=605; // Ctrl+Close Bracket
			keyMap[Magix++]=603; // Ctrl+Open Bracket
			keyMap[Magix++]=560; // Ctrl+0
			keyMap[Magix++]=569; // Ctrl+9
			keyMap[Magix++]=568; // Ctrl+8
			keyMap[Magix++]=567; // Ctrl+7
			keyMap[Magix++]=566; // Ctrl+6
			keyMap[Magix++]=595; // Ctrl+S
			keyMap[Magix++]=588; // Ctrl+L
			keyMap[Magix++]=851; // Ctrl+Shift+S
			keyMap[Magix++]=577; // Ctrl+A
			keyMap[Magix++]=2097; // Alt+1
			keyMap[Magix++]=2098; // Alt+2
			keyMap[Magix++]=2099; // Alt+3
			keyMap[Magix++]=2100; // Alt+4
			keyMap[Magix++]=704; // Ctrl+Back Quote
			keyMap[Magix++]=604; // Ctrl+Back Slash
			keyMap[Magix++]=829; // Ctrl+Shift+Equals
			keyMap[Magix++]=557; // Ctrl+Minus
			keyMap[Magix++]=861; // Ctrl+Shift+Close Bracket
			keyMap[Magix++]=859; // Ctrl+Shift+Open Bracket
			keyMap[Magix++]=573; // Ctrl+Equals
			keyMap[Magix++]=32; // Space
		}

		static Cartridge cart = null;

		public void init() {
			JLabel label = new JLabel("The emulator will be opened in a new window.");
			getContentPane().add(label);
		}

		boolean debug = false;
		static Image logo = null;
		public static void starter(swinggui gui, String[] args) {
			Thread.setDefaultUncaughtExceptionHandler(new GlobalExceptionCatcher());

			boolean sound=true, debug=false, lastcart=false;
			String romfile="", logfile="", remotedebugoffset = "0";
			for (int i = 0; i < args.length; ++i) {
				if (args[i].charAt(0)!='-')
					romfile = args[i];
				if (args[i].equals("-log"))
					logfile = args[++i];
				if (args[i].equals("-nosound"))
					sound = false;
				if (args[i].equals("-sound"))
					sound = true;
				if (args[i].equals("-debug"))
					debug = true;
				if (args[i].equals("-rdo"))
					remotedebugoffset = args[++i];
				if ((args[i].equals("-lastcart"))) //TODO: FIXME: Invert this (current behaviour is a work-around)
					lastcart=true;
			}

			gui.debug = debug;

			if(!lastcart) {
				Toolkit toolkit = Toolkit.getDefaultToolkit();
				URL imgurl = gui.getClass().getResource("jgbe_logo.png");
				gui.logo = null;
				if(imgurl!=null) {
					logo = toolkit.getImage(imgurl);
					while((gui.logo.getWidth(null)==-1) || (gui.logo.getHeight(null)==-1)) YIELD;
				}
				else {
					PRINTLN("Can't load JGBE logo!");
				}
			}

			gui.loadRCFiles();
			if(lastcart && (gui.rcFiles.size() > 0))
				romfile = (String)gui.rcFiles.get(0);

			gui.cpu = new CPU();

			gui.VC = gui.cpu.VC;
			gui.cs = new ColorSelector( gui );
			gui.createGUI();

			if(sound) {
				gui.audioDriver = new AudioDriver(gui.cpu.AC);
				CPU.AC.addIAudioListener(gui.audioDriver);
				advancedAudioPropertiesDialog = new AdvancedAudioPropertiesDialog(frame, gui.audioDriver, gui);
			}

			if (!romfile.equals(""))
				gui.tryToLoadROM(romfile);

			cheatcodes = new CheatCodeEditor(frame, curcartname);

			cheatcodes.applyCheatCodes(cart);

			gui.loadConfig();

			if (gui.menuitemUseBIOS.getState() && cart != null) cart.loadBios(biosfilename);
			gui.loadKeyBinds();

			gui.cpu.VC.addListener(gui.grfx);
			if (!sound)
				gui.cpu.AC.isMuted = true;

			Timer timer = new Timer(250, gui);
			timer.setInitialDelay(250);
			timer.start();

			if (cart != null)
				gui.cpu.loadCartridge(cart);

			gui.makeRcFilesMenuItems();

			//DEBUGGER
			if (debug) {
				Debugger dbgr = new Debugger(gui, logfile); //The GUI to which this debugger belongs
				PRINTLN("Parsing long" + remotedebugoffset);
				long l = Long.parseLong(remotedebugoffset);
				PRINTLN("Setting");
				dbgr.setRemoteDebugOffset(l);
				PRINTLN("Running");
				gui.cpuRunner = dbgr.runner;
			}
			else {
				gui.cpuRunner = new SimpleCPURunner();
				gui.resumeEmulation(false);
			}
			gui.showGUI();
			PRINTFREEMEM("Emulator up & running");
		}

		public void start() {
			try {
				isApplet = true;
				final swinggui gui=this;
				String[] args = getParameter("params").split(" ");
				starter(gui, args);
			} catch (Exception e) {
				// prevent browser crash on unchecked exception
			}
		}

		public static void main(String[] args) {
			final swinggui gui=new swinggui();
			starter(gui, args);
		}

		public void windowActivated(WindowEvent e) {
			if (deactcount == -1) {
				enableFullScreen.setState(true);
				componentResized(null);
			}

			deactcount = 0;
		}
		public void windowClosing(WindowEvent e) {
			windowClosed(e);
		}

		public void windowDeactivated(WindowEvent e) {
			deactcount = 2; // would like this to be 1, or even lower
			                // but than can make a real fullscreen request be cancelled
		}

		public void windowDeiconified(WindowEvent e) {}
		public void windowIconified(WindowEvent e) {}
		public void windowOpened(WindowEvent e) {}
		public void windowClosed(WindowEvent e) {
			if (isApplet) {
				try {
					getAppletContext().showDocument(new URL("http://code.google.com/p/jgbe/"));
				} catch ( MalformedURLException ex) {
					//ex.printstacktrace();
				}
			} else {
				System.exit(0);
			}
		}

		public void mouseMoved(MouseEvent e) {
			if (mousehidden == 1) {
				mousehidden = 2;
				return;
			}
			if (mousehidden == 2) {
				addOSDLine("Unhiding mouse");
				try {
					new Robot().mouseMove(lastmousex, lastmousey);
				} catch (AWTException ex) {
				}
				mousehidden = 0;
				return;
			}
			lastmousecnt = 60 * 3;

			lastmousex = e.getX();
			lastmousey = e.getY();
		}

		public void mouseDragged(MouseEvent e) {
			mouseMoved(e);
		}
	}
#endif
